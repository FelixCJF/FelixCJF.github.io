<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>菜鸟Java成长之路</title>
  <subtitle>半途而废便是最大的失败</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2017-06-23T01:38:45.507Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Felix</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Activiti流程框架上手</title>
    <link href="http://yoursite.com/2017/06/22/Activiti%E6%B5%81%E7%A8%8B%E6%A1%86%E6%9E%B6%E4%B8%8A%E6%89%8B/"/>
    <id>http://yoursite.com/2017/06/22/Activiti流程框架上手/</id>
    <published>2017-06-22T09:12:42.000Z</published>
    <updated>2017-06-23T01:38:45.507Z</updated>
    
    <content type="html"><![CDATA[<p>Activiti其核心是BPMN2.0 的流程引擎，是覆盖了业务流程管理、工作流、服务协作等领域的一个开源的、灵活的、易扩展的可执行流程语言框架<br><a id="more"></a><br><a href="https://www.activiti.org/quick-start" target="_blank" rel="external">官网quick-start</a><br><a href="http://itmyhome.com/activiti/#download" target="_blank" rel="external">Activiti 5.16 中文用户手册</a></p>
<p>简单使用介绍，深入需自行查文档   </p>
<h1 id="Activiti介绍"><a href="#Activiti介绍" class="headerlink" title="Activiti介绍"></a>Activiti介绍</h1><p><img src="http://oje7mvhbz.bkt.clouddn.com/%E7%BB%93%E6%9E%84%E5%9B%BE.png" alt="Activiti结构图"></p>
<h2 id="工作流引擎ProcessEngine"><a href="#工作流引擎ProcessEngine" class="headerlink" title="工作流引擎ProcessEngine"></a>工作流引擎ProcessEngine</h2><p>这是Activiti工作的核心。负责生成流程运行时的各种实例及数据、监控和管理流程的运行。<br><strong>产生方式：</strong>    </p>
<pre><code>//方式一
ProcessEngine processEngine = ProcessEngineConfiguration
            .createProcessEngineConfigurationFromResource(&quot;activiti.cfg.xml&quot;)
            .buildProcessEngine();  
//方式二
ProcessEngine processEngine = ProcessEngines.getDefaultProcessEngine();//自动加载classpath下的activiti.cfg.xml
</code></pre><p><strong>主要Service的作用：</strong>   </p>
<ul>
<li><p><strong>Repository Service</strong> 提供了管理和控制发布包和流程的定义操作。如：部署流程定义；查询引擎中的已有发布包和流程定义；暂停或激活发布包；获取发布包中的资源，如xml文件或是流程图片等。     </p>
</li>
<li><p><strong>Runtime Service</strong> 负责启动一个流程顶的新实例。对于每个流程定义来说，同一个时间内，可以有多个实例在执行。runtime service还可以用于获取和保存流程实例中的变量。或是用于查询流程实例，执行实例，触发实例等。   </p>
</li>
<li><p><strong>Task Service</strong> 任务相关的服务。包含功能：查询分配给用户或用户组的任务的信息；创建独立运行于流程实例外的任务；手段设置任务与用户的关联关系；认领(claim)任务， 完成(complete)任务等。         </p>
</li>
<li><p>Identity Service 负责管理（创建，更新，删除，查询…）群组和用户。注意，activiti执行时不会对用户执行检查。任务可以分配给任何人，无论这个用户是否存在。</p>
</li>
<li><p>Form Service 表单服务。可选的。提供启动表单和任务表单两个概念。即在流程实例启动前展示给用户的，和完成任务时展示给用户的两种表单。注意，这是个可选服务，表单不一定需要嵌入到流程定义中。</p>
</li>
<li><p><strong>History Service</strong> 历史数据服务。执行流程时，引擎会保存如实例启动时间，任务参与者，完成时间，执行路径等数据。Histroy Service通过查询功能获取这些数据。</p>
</li>
<li><p>Management Service 管理服务。提供查询和管理异步操作的功能。异步操作的用途包含定时器，延迟，暂停，激活等。</p>
</li>
</ul>
<h2 id="BPMN2-0"><a href="#BPMN2-0" class="headerlink" title="BPMN2.0"></a>BPMN2.0</h2><p>业务流程建模与标注（Business Process Model and Notation，BPMN) ，描述流程的基本符号，包括这些图元如何组合成一个业务流程图（Business Process Diagram），可以安装eclipse插件，直接建立bpmn图</p>
<h2 id="eclipse插件安装"><a href="#eclipse插件安装" class="headerlink" title="eclipse插件安装"></a>eclipse插件安装</h2><ol>
<li>打开 Help -&gt; Install New Software. </li>
<li>在Install界面板中，点击Add按钮</li>
<li><p>然后填入下列字段 </p>
<pre><code>Name: Activiti BPMN 2.0 designer
Location: http://activiti.org/designer/update/
</code></pre></li>
<li>回到Install界面，在面板正中列表中把所有展示出来的项目都勾上</li>
<li>安装完以后，点击新建工程new-&gt;Other…打开面板，如果看到下图内容则安装成功：<br><img src="http://oje7mvhbz.bkt.clouddn.com/%E6%8F%92%E4%BB%B6.png" alt="插件安装"></li>
<li>打开菜单Windows-&gt;Preferences-&gt;Activiti-&gt;Save下流程流程图片的生成方式:<br><img src="http://oje7mvhbz.bkt.clouddn.com/%E6%8F%92%E4%BB%B6%E4%BD%BF%E7%94%A8.png" alt=""><h2 id="相关数据库"><a href="#相关数据库" class="headerlink" title="相关数据库"></a>相关数据库</h2>Activiti的后台是有数据库的支持，所有的表都以ACT_开头。 第二部分是表示表的用途的两个字母标识。 用途也和服务的API对应。使用Activiti自动建表策略，创建引擎时会自动建立25张表，如下图：<br><img src="http://oje7mvhbz.bkt.clouddn.com/%E8%A1%A8.png" alt="25张相关表"></li>
</ol>
<ul>
<li>ACT<em> RE</em>*: ‘RE’表示repository。 这个前缀的表包含了流程定义和流程静态资源 （图片，规则，等等）。</li>
<li>ACT<em> RU</em>*: ‘RU’表示runtime。 这些运行时的表，包含流程实例，任务，变量，异步任务，等运行中的数据。Activiti只在流程实例执行过程中保存这些数据， 在流程结束时就会删除这些记录。 这样运行时表可以一直很小速度很快。</li>
<li>ACT<em> ID</em>*: ‘ID’表示identity。 这些表包含身份信息，比如用户，组等等。</li>
<li>ACT<em> HI</em>*: ‘HI’表示history。 这些表包含历史数据，比如历史流程实例， 变量，任务等等。</li>
<li>ACT<em> GE</em>*: 通用数据， 用于不同场景下。</li>
</ul>
<h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><p>建立activiti.cfg.xml文件，Activiti核心配置文件，配置流程引擎创建工具的基本参数和数据库连接池参数。可以和spring整合。</p>
<pre><code>&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
    xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;
    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
    http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-2.5.xsd
    http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-3.0.xsd&quot;&gt;

    &lt;!-- 定义流程引擎配置对象 --&gt;
    &lt;bean id=&quot;processEngineConfiguration&quot;     class=&quot;org.activiti.engine.impl.cfg.StandaloneProcessEngineConfiguration&quot;&gt;
        &lt;!-- 配置数据库驱动 --&gt;
        &lt;property name=&quot;jdbcDriver&quot; value=&quot;com.mysql.jdbc.Driver&quot;&gt;&lt;/property&gt;
        &lt;!-- 配置数据库url --&gt;
        &lt;property name=&quot;jdbcUrl&quot; value=&quot;jdbc:mysql://localhost:3306/actdemo?characterEncoding=UTF-8&quot;&gt;&lt;/property&gt;
        &lt;!-- 配置数据库用户名 --&gt;
        &lt;property name=&quot;jdbcUsername&quot; value=&quot;root&quot;&gt;&lt;/property&gt;
        &lt;!-- 配置数据库密码 --&gt;
        &lt;property name=&quot;jdbcPassword&quot; value=&quot;&quot;&gt;&lt;/property&gt;
        &lt;!-- 配置数据库建表策略，自动建立25张相关表 --&gt;
        &lt;property name=&quot;databaseSchemaUpdate&quot; value=&quot;true&quot;&gt;&lt;/property&gt;
        &lt;!-- 
            Actiivit提供了4中历史记录级别
                none:不保存任何记录,可以提高系统性能
                activity:保存所有的流程实例，任务，活动信息
                auit:默认级别,保存所有实例，任务，活动，表单属性
                full:最完整的,除了auit中的，还能保存更加详细的信息，如流程变量
         --&gt;
         &lt;property name=&quot;history&quot; value=&quot;activity&quot;&gt;&lt;/property&gt;
    &lt;/bean&gt;

&lt;/beans&gt;
</code></pre><h1 id="流程定义语言"><a href="#流程定义语言" class="headerlink" title="流程定义语言"></a>流程定义语言</h1><p><img src="http://oje7mvhbz.bkt.clouddn.com/%E8%AF%B7%E5%81%87%E6%B5%81%E7%A8%8B.png" alt="请假流程"></p>
<h2 id="流程-process"><a href="#流程-process" class="headerlink" title="流程(process)"></a>流程(process)</h2><p>bpmn文件一个流程的根元素。一个流程就代表一个工作流。</p>
<h2 id="顺序流-sequenceFlow"><a href="#顺序流-sequenceFlow" class="headerlink" title="顺序流(sequenceFlow )"></a>顺序流(sequenceFlow )</h2><p>顺序流是连接两个流程节点的连线，代表一个节点的出口。流程执行完一个节点后，会沿着节点的所有外出顺序流继续执行。 就是说，BPMN 2.0默认的行为就是并发的： 两个外出顺序流会创造两个单独的，并发流程分支。<br>顺序流主要由4个属性组成：<br><strong>Id:</strong> 唯一标示，用来区分不同的顺序流<br><strong>sourceRef：</strong>连线的源头节点ID<br><strong>targetRef：</strong> 连线的目标节点ID<br><strong>name（可选）：</strong> 连线的名称，不涉及业务，主要用于显示   </p>
<ul>
<li>结束节点没有出口</li>
<li>其他节点有一个或多个出口。如果有一个出口，则代表是一个单线流程；如果有多个出口，则代表是开启并发流程。</li>
</ul>
<h1 id="请假流程快速实现（测试）"><a href="#请假流程快速实现（测试）" class="headerlink" title="请假流程快速实现（测试）"></a>请假流程快速实现（测试）</h1><h2 id="建立maven工程引入依赖"><a href="#建立maven工程引入依赖" class="headerlink" title="建立maven工程引入依赖"></a>建立maven工程引入依赖</h2><pre><code>&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
&lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
&lt;groupId&gt;com.rtzc&lt;/groupId&gt;
&lt;artifactId&gt;activitiDemoProject&lt;/artifactId&gt;
&lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;

&lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.activiti&lt;/groupId&gt;
        &lt;artifactId&gt;activiti-engine&lt;/artifactId&gt;
        &lt;version&gt;5.22.0&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.slf4j&lt;/groupId&gt;
        &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt;
        &lt;version&gt;1.7.21&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.slf4j&lt;/groupId&gt;
        &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt;
        &lt;version&gt;1.7.21&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;!-- https://mvnrepository.com/artifact/mysql/mysql-connector-java --&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;mysql&lt;/groupId&gt;
        &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
        &lt;version&gt;5.1.22&lt;/version&gt;
    &lt;/dependency&gt;

    &lt;dependency&gt;
        &lt;groupId&gt;junit&lt;/groupId&gt;
        &lt;artifactId&gt;junit&lt;/artifactId&gt;
        &lt;version&gt;3.8.1&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;!-- https://mvnrepository.com/artifact/commons-io/commons-io --&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;commons-io&lt;/groupId&gt;
        &lt;artifactId&gt;commons-io&lt;/artifactId&gt;
        &lt;version&gt;2.4&lt;/version&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;
&lt;/project&gt;
</code></pre><h2 id="建立bpmn图片或者bpmn的xml文件"><a href="#建立bpmn图片或者bpmn的xml文件" class="headerlink" title="建立bpmn图片或者bpmn的xml文件"></a>建立bpmn图片或者bpmn的xml文件</h2><ol>
<li>使用bpmn,建立bpmn如下图，部署后，系统会自动解析，可以在properties选项卡下设置相关属性，我使用的是这种方式<br><img src="http://oje7mvhbz.bkt.clouddn.com/%E8%AF%B7%E5%81%87%E6%B5%81%E7%A8%8B.png" alt="请假流程"></li>
</ol>
<ol>
<li>使用bpmn的xml文件，流程定义文件，在部署后，每次系统启动时都会被解析，把内容封装成流程定义放入项目缓存中。Activiti框架结合这个xml文件自动管理流，</li>
</ol>
<pre><code>&lt;definitions  xmlns=&quot;http://www.omg.org/spec/BPMN/20100524/MODEL&quot;  xmlns:activiti=&quot;http://activiti.org/bpmn&quot;  targetNamespace=&quot;Examples&quot;&gt;        
&lt;!-- 流程定义部分 --&gt;  
&lt;processid=&quot;myProcess&quot;name=&quot;My First Process&quot;&gt;           
    &lt;startEvent id=&quot;startevent1&quot; name=&quot;Start&quot;&gt;&lt;/startEvent&gt;                
    &lt;endEvent id=&quot;endevent1&quot; name=&quot;End&quot;&gt;&lt;/endEvent&gt;        
    &lt;userTask id=&quot;usertask1&quot; name=&quot;员工申请请假&quot;  activiti:assignee=&quot;员工&quot;&gt;&lt;/userTask&gt;        
    &lt;userTask id=&quot;usertask2&quot; name=&quot;项目经理审批&quot;  activiti:assignee=&quot;经理&quot;&gt;&lt;/userTask&gt;        
    &lt;userTask id=&quot;usertask3&quot; name=&quot;总经理审批&quot;  activiti:assignee=&quot;老板&quot;&gt;&lt;/userTask&gt;        
    &lt;sequenceFlow id=&quot;flow1&quot; sourceRef=&quot;startevent1&quot; targetRef=&quot;usertask1&quot;&gt;&lt;/sequenceFlow&gt;        
    &lt;sequenceFlow id=&quot;flow2&quot; name=&quot;提交申请&quot; sourceRef=&quot;usertask1&quot; argetRef=&quot;usertask2&quot;&gt;&lt;/sequenceFlow&gt;        
    &lt;sequenceFlow id=&quot;flow3&quot; name=&quot;项目经理审批&quot; sourceRef=&quot;usertask2&quot;  argetRef=&quot;usertask3&quot;&gt;&lt;/sequenceFlow&gt;        
    &lt;sequenceFlow id=&quot;flow4&quot; name=&quot;总经理审批&quot; sourceRef=&quot;usertask3&quot;  argetRef=&quot;endevent1&quot;&gt;&lt;/sequenceFlow&gt;        
&lt;/process&gt;            
&lt;!-- BPMN绘图规范定义部分（用来描述节点图标的大小和坐标） --&gt;
&lt;bpmndi:BPMNDiagram id=&quot;BPMNDiagram_myProcess&quot;&gt;
....
&lt;/bpmndi:BPMNDiagram&gt;
&lt;/definitions&gt;
</code></pre><h2 id="部署流程定义"><a href="#部署流程定义" class="headerlink" title="部署流程定义"></a>部署流程定义</h2><pre><code>/**
 * 部署流程定义
 */
@Test
public void deploy() {
    // 创建流程引擎
    ProcessEngine processEngine = ProcessEngines.getDefaultProcessEngine();
    // 创建部署环境变量
    DeploymentBuilder deploymentBuilder = processEngine
            .getRepositoryService().createDeployment();
    // 部署流程
    Deployment deployment = deploymentBuilder.name(&quot;请假部署测试&quot;)//部署流程显示名称
            .addClasspathResource(&quot;请假流程.bpmn&quot;)//设置流程文件
            .addClasspathResource(&quot;请假流程.png&quot;)
            .deploy();//部署
    //打印部署id
    System.out.println(&quot;部署id为&quot;+deployment.getId()+&quot;部署名称为&quot;+deployment.getName() );
}
</code></pre><p>说明：     </p>
<ol>
<li>通过流程引擎获取了一个RepositoryService对象-&gt;仓库服务对象     </li>
<li>由仓库的服务对象产生一个部署对象配置对象，用来封装部署环境的相关配置。   </li>
<li>在部署配置对象中设置显示名，上传规则文件相对classpath的地址。</li>
<li>部署，往数据库中存储流程定义的过程。操作了三张表这一步</li>
</ol>
<p><strong>act_ re_deployment</strong> 存放流程定义的显示名和部署时间，每部署一次增加一条记录             </p>
<p><strong>act_ re_procdef</strong> 存放流程定义的属性信息，部署每个新的流程定义都会在这张表中增加一条记录。<br><strong>act_ge_bytearray</strong>    存储流程定义相关的部署信息。即流程定义文档的存放地。每部署一次就会增加两条记录，一条是关于bpmn规则文件的，一条是图片的（如果部署时只指定了bpmn一个文件，activiti会在部署时解析bpmn文件内容自动生成流程图）。以二进制形式存储在数据库中。</p>
<h2 id="查询流程定义的相关信息"><a href="#查询流程定义的相关信息" class="headerlink" title="查询流程定义的相关信息"></a>查询流程定义的相关信息</h2><pre><code>/**
 * 查看流程规则信息
 */
@Test
public void view(){
    // 创建流程引擎
    ProcessEngine processEngine = ProcessEngines.getDefaultProcessEngine();
    //获取流程定义信息
    List&lt;ProcessDefinition&gt; definitions = processEngine.getRepositoryService()
                .createProcessDefinitionQuery()//创建流程定义查询对象
                .list();//执行查询，也可以添加过滤和排序分页条件

    //迭代查询出来的流程定义
    for (ProcessDefinition processDefinition : definitions) {
        System.out.println(&quot;id=&quot;+processDefinition.getId());
        System.out.println(&quot;name=&quot;+processDefinition.getName());
        System.out.println(&quot;key=&quot;+processDefinition.getKey());
        System.out.println(&quot;version=&quot;+processDefinition.getVersion());
        System.out.println(&quot;depolymentId=&quot;+processDefinition.getDeploymentId());
        System.out.println(&quot;-----------查询完毕----------&quot;);
    }

}
</code></pre><p>查询结果：   </p>
<pre><code>id=leaveFlow:1:25004
name=leaveFlow
key=leaveFlow
version=1
depolymentId=25001
-----------查询完毕----------
id=leaveFlow:2:32504
name=leaveFlow
key=leaveFlow
version=2
depolymentId=32501
-----------查询完毕----------
</code></pre><p>说明：    </p>
<ul>
<li>key属性被用来区别不同的流程定义。              </li>
<li>带有特定key的流程定义第一次部署时，version为1。之后每次部署都会在当前最高版本号上加1         </li>
<li>Id的值的生成规则为:{processDefinitionKey}:{processDefinitionVersion}:{generated-id}, 这里的generated-id是一个自动生成的唯一的数字</li>
<li>重复部署一次，deploymentId的值以一定的形式变化     </li>
<li>流程定义(ProcessDefinition)在数据库中没有相应的表对应，只是从act_ge_bytearray表中取出相应的bpmn和png图片，并进行解析。</li>
</ul>
<h2 id="删除流程定义"><a href="#删除流程定义" class="headerlink" title="删除流程定义"></a>删除流程定义</h2><pre><code>/**
 * 删除流程定义
 */
@Test
public void delete(){
    //创建流程引擎
    ProcessEngine processEngine = ProcessEngines.getDefaultProcessEngine();
    //流程定义id
    String deploymentId = &quot;20001&quot;;
    //删除指定的部署信息，如果有关联，则报错,一般用这个,级联涉及数据较多，一般是超级管理员权限
    //processEngine.getRepositoryService().deleteDeployment(deploymentId);
    //删除指定的部署信息，如果有关联，则级联删除,cascade参数代表是否级联删除
    processEngine.getRepositoryService().deleteDeployment(deploymentId, true);

}
</code></pre><p>说明：   </p>
<ul>
<li>因为删除的是流程定义，而流程定义的部署是属于仓库服务的，所以应该先得到RepositoryService    </li>
<li>如果该流程定义下没有正在运行的流程，则可以用普通方法进行删除。如果是有关联的信息，则需要用方法进行级联删除。一般情况下用普通删除就可以。级联删除涉及的数据比较多，一般只开放给超级管理员使用。</li>
</ul>
<h2 id="查询出流程图片（用来显示流程图片）"><a href="#查询出流程图片（用来显示流程图片）" class="headerlink" title="查询出流程图片（用来显示流程图片）"></a>查询出流程图片（用来显示流程图片）</h2><pre><code>/**
 * 查询流程定义文档（主要是流程图片）
 */
@Test
public void queryResource() throws Exception{
    // 创建流程引擎
    ProcessEngine processEngine = ProcessEngines.getDefaultProcessEngine();
    // 流程定义id
    String deploymentId = &quot;10001&quot;;
    List&lt;String&gt; names = processEngine.getRepositoryService().getDeploymentResourceNames(deploymentId);
    String resourceName = null;
    //遍历资源文件名列表
    for (String string : names) {
        //获取以.png后缀的文件名
        if (string.lastIndexOf(&quot;.png&quot;)&gt;=0) {
            resourceName = string;
        }
    }
    //如果流程图片存在
    if (resourceName != null) {
        File file = new File(&quot;D:/&quot;+resourceName);
        //通过流程图片对应的id和名称获得对应的输入流
        InputStream in = processEngine.getRepositoryService().getResourceAsStream(deploymentId, resourceName);
        //使用fileUtils把图片拷贝至指定目录下
        FileUtils.copyInputStreamToFile(in, file);
    }
}
</code></pre><p>说明：       </p>
<ul>
<li>deploymentId为流程部署ID</li>
<li>resourceName为act_ge<em>bytearray表中NAME</em>列的值</li>
<li>使用repositoryService的getDeploymentResourceNames方法可以获取指定部署下得所有文件的名称</li>
<li>使用repositoryService的getResourceAsStream方法传入部署ID和文件名称可以获取部署下指定名称文件的输入流</li>
<li>最后的有关IO流的操作，使用FileUtils工具的copyInputStreamToFile方法完成流程流程到文件的拷贝</li>
</ul>
<h2 id="开始流程"><a href="#开始流程" class="headerlink" title="开始流程"></a>开始流程</h2><pre><code>/**
 * 启动流程实例
 *         启动流程实例，返回流程实例对象，停在start后的第一个节点上
 */
@Test
public void startProcess(){
    //创建流程引擎
    ProcessEngine processEngine = ProcessEngines.getDefaultProcessEngine();
    //获取流程运行时服务对象
    RuntimeService runtimeService = processEngine.getRuntimeService();
    //启动流程实例，返回实例对象
    ProcessInstance processInstance = runtimeService.startProcessInstanceByKey(&quot;leaveFlow&quot;);
    //显示相关信息
    System.out.println(&quot;流程实例ID=&quot;+processInstance.getId());
    System.out.println(&quot;当前活动节点ID=&quot;+processInstance.getActivityId());

}
</code></pre><p>结果显示：  </p>
<pre><code>流程实例ID=40001
当前活动节点ID=usertask1
</code></pre><p>说明：  </p>
<ul>
<li>操作数据库的act_ru_execution表,如果是用户任务节点，同时也会在act_ru_task添加一条记录</li>
</ul>
<h2 id="查询待办任务"><a href="#查询待办任务" class="headerlink" title="查询待办任务"></a>查询待办任务</h2><pre><code>/**
 * 查询指定用户的待办任务
 * 
 */
@Test
public void findUnfinshTask() {
    // 创建流程引擎
    ProcessEngine processEngine = ProcessEngines.getDefaultProcessEngine();
    String assignee = &quot;员工&quot;;
    //查询个人的代办任务
    List&lt;Task&gt; tasks = processEngine.getTaskService()
            .createTaskQuery()//创建流程任务查询对象
            .taskAssignee(assignee)//添加过滤条件
            //.listPage(firstResult, maxResults)添加分页
            .orderByTaskCreateTime().desc()//排序
            .list();//执行查询
    System.out.println(&quot;------&quot;+assignee+&quot;的个人任务列表------&quot;);
    for (Task task : tasks) {
        System.out.println(&quot;任务ID:&quot;+task.getId());
        System.out.println(&quot;任务名称:&quot;+task.getName());
        System.out.println(&quot;任务办理者:&quot;+task.getAssignee());
        System.out.println(&quot;任务创建时间:&quot;+task.getCreateTime());
        System.out.println(&quot;任务执行对象的ID:&quot;+task.getExecutionId());
    }

}
</code></pre><p>显示结果：     </p>
<pre><code>------员工的个人任务列表------   
任务ID:40004
任务名称:员工请假申请
任务办理者:员工
任务创建时间:Fri Jun 23 08:33:08 CST 2017
任务执行对象的ID:40001
任务ID:32508
任务名称:员工请假申请
任务办理者:员工
任务创建时间:Thu Jun 22 16:50:10 CST 2017
任务执行对象的ID:32505  
</code></pre><p>说明：    </p>
<ul>
<li>因为是任务查询，所以从processEngine中应该得到TaskService</li>
<li>使用TaskService获取到任务查询对象TaskQuery</li>
<li>为查询对象添加查询过滤条件，使用taskAssignee指定任务的候选者（即查询指定用户的代办任务），添加分页排序等过滤条件</li>
<li>调用list方法执行查询，返回办理者为指定用户的任务列表</li>
<li>任务ID、名称、办理人、创建时间可以从act_ru_task表中查到。</li>
<li>在这种情况下，ProcessInstance相当于Execution</li>
<li>一个Task节点和Execution节点是1对1的情况，在task对象中使用Execution_来标示他们之间的关系</li>
<li>任务ID在数据库表act<em> ru</em> task中对应“ID_”列</li>
</ul>
<h2 id="可领取任务查询和领取"><a href="#可领取任务查询和领取" class="headerlink" title="可领取任务查询和领取"></a>可领取任务查询和领取</h2><pre><code>/**
 * 查询指定用户的可以领取的任务
 * 
 */
@Test
public void findCanTakeTask() {
    // 创建流程引擎
    ProcessEngine processEngine = ProcessEngines.getDefaultProcessEngine();
    String candidateUser = &quot;员工&quot;;
    //查询个人的代办任务
    List&lt;Task&gt; tasks = processEngine.getTaskService()
            .createTaskQuery()//创建流程任务查询对象
            .taskCandidateUser(candidateUser)//代表过滤任务候选者为自己的任务
            //.listPage(firstResult, maxResults)添加分页
            .orderByTaskCreateTime().desc()//排序
            .list();//执行查询
    System.out.println(&quot;------&quot;+candidateUser+&quot;的个人任务列表------&quot;);
    for (Task task : tasks) {
        System.out.println(&quot;任务ID:&quot;+task.getId());
        System.out.println(&quot;任务名称:&quot;+task.getName());
        System.out.println(&quot;任务办理者:&quot;+task.getAssignee());
        System.out.println(&quot;任务创建时间:&quot;+task.getCreateTime());
        System.out.println(&quot;任务执行对象的ID:&quot;+task.getExecutionId());
    }

}
/**
 * 查询指定用户的可以领取的任务
 * 
 */
@Test
public void findCanTakeTask() {
    // 创建流程引擎
    ProcessEngine processEngine = ProcessEngines.getDefaultProcessEngine();
    String candidateUser = &quot;员工1&quot;;
    //查询个人的代办任务
    List&lt;Task&gt; tasks = processEngine.getTaskService()
            .createTaskQuery()//创建流程任务查询对象
            .taskCandidateUser(candidateUser)//代表过滤任务候选者为自己的任务
            //.listPage(firstResult, maxResults)添加分页
            .orderByTaskCreateTime().desc()//排序
            .list();//执行查询
    System.out.println(&quot;------&quot;+candidateUser+&quot;的个人任务列表------&quot;);
    for (Task task : tasks) {
        System.out.println(&quot;任务ID:&quot;+task.getId());
        System.out.println(&quot;任务名称:&quot;+task.getName());
        System.out.println(&quot;任务办理者:&quot;+task.getAssignee());
        System.out.println(&quot;任务创建时间:&quot;+task.getCreateTime());
        System.out.println(&quot;任务执行对象的ID:&quot;+task.getExecutionId());
    }

}

/**
 * 公共任务的认领
 */
@Test
public void takeTask(){
    // 创建流程引擎
    ProcessEngine processEngine = ProcessEngines.getDefaultProcessEngine();
    // 接手得任务ID
    String taskId = &quot;&quot;;
    // 员工ID
    String userId = &quot;&quot;;
    //认领任务
    processEngine.getTaskService().claim(taskId, userId);
}
</code></pre><p>说明：   </p>
<ul>
<li>在查询对象上，添加taskCandidateUser过滤条件，代表过滤任务候    选者为自己的任务</li>
<li>所有公共任务的assignee属性为空</li>
<li>调用taskService的claim（认领）方法，把公共任务变成指定用户的私有任务</li>
</ul>
<h2 id="办理任务"><a href="#办理任务" class="headerlink" title="办理任务"></a>办理任务</h2><pre><code>/**
 * 任务的办理,完成任务后,使流程往后进行
 */
@Test
public void completeTask() {
    // 创建流程引擎
    ProcessEngine processEngine = ProcessEngines.getDefaultProcessEngine();
    // 指定任务id
    String taskId = &quot;35002&quot;;
    // 完成任务
    processEngine.getTaskService().complete(taskId);
}
</code></pre><p>说明：  </p>
<ul>
<li>是办理任务，所以从ProcessEngine得到的是TaskService。</li>
<li>当执行完这段代码，再以员工的身份去执行查询的时候，会发现这个时候已经没有数据了。</li>
<li>对于执行完的任务，activiti将从act_ru_task表中删除该任务，下一个任务会被插入进来。</li>
<li>以”项目经理”的身份进行查询，可以查到结果。因为流程执行到项目经理审批这个节点了。</li>
<li>再执行办理任务代码，执行完以后以”项目经理”身份进行查询，没有结果。</li>
<li>重复上面的直到流程执行完。</li>
</ul>
<h2 id="验证流程是否结束，查看历史流程"><a href="#验证流程是否结束，查看历史流程" class="headerlink" title="　验证流程是否结束，查看历史流程"></a>　验证流程是否结束，查看历史流程</h2><pre><code>/**
 * 验证流程已结束
 */
@Test
public void checkTaskEnded() {
    // 创建流程引擎
    ProcessEngine processEngine = ProcessEngines.getDefaultProcessEngine();
    // 流程定义ID
    String processId = &quot;leaveFlow:1:25004&quot;;
    //通过流程定义Id获取到流程定义对象
    ProcessInstance processInstance = processEngine.getRuntimeService()
                                            .createProcessInstanceQuery()
                                            .processInstanceId(processId)
                                            .singleResult();
    //查看实例是否完成
    if (processInstance!= null) {
        System.out.println(&quot;当前活动节点为&quot;+processInstance.getActivityId());
    }else {
        System.out.println(&quot;ID为【&quot;+processId+&quot;】的实例流程已经结束&quot;);
    }
}

/**
 * 查看历史流程，某个用户一共执行了多少次请假流程
 * 
 */
@Test
public void queryHistoryInstance() {
    // 创建流程引擎
    ProcessEngine processEngine = ProcessEngines.getDefaultProcessEngine();
    // 指定流程定义Id
    String processDefinitionId = &quot;leaveFlow:1:25004&quot;;
    // 查询历史流程实例
    List&lt;HistoricProcessInstance&gt; list = processEngine.getHistoryService()
            .createHistoricProcessInstanceQuery()
            .processDefinitionId(processDefinitionId)//安装该流程定义id
            .finished()//已完成
            .orderByProcessInstanceStartTime().desc()//排序
            .list();
    for (HistoricProcessInstance historicProcessInstance : list) {
        System.out.println(&quot;ID:&quot;+historicProcessInstance.getProcessDefinitionId());
        System.out.println(&quot;开始活动ID:&quot;+historicProcessInstance.getStartActivityId());
        System.out.println(&quot;开始时间:&quot;+historicProcessInstance.getStartTime());
        System.out.println(&quot;结束时间:&quot;+historicProcessInstance.getEndTime());
    }

}

/**
 * 查看历史流程活动  查看某一次流程所经历的步骤
 */
@Test
public void queryHistoryActivit() {
    // 创建流程引擎
    ProcessEngine processEngine = ProcessEngines.getDefaultProcessEngine();
    // 指定流程定义Id
    String processDefinitionId = &quot;leaveFlow:1:25004&quot;;
    //查询历史流程
    List&lt;HistoricActivityInstance&gt; list = processEngine.getHistoryService()
                                .createHistoricActivityInstanceQuery()
                                .processInstanceId(processDefinitionId)
                                .list();
    for (HistoricActivityInstance historicActivityInstance : list) {
        System.out.println(&quot;ID:&quot;+historicActivityInstance.getProcessDefinitionId());
        System.out.println(&quot;开始活动ID:&quot;+historicActivityInstance.getActivityId());
        System.out.println(&quot;开始活动名称:&quot; + historicActivityInstance.getActivityName());
        System.out.println(&quot;开始时间:&quot;+historicActivityInstance.getStartTime());
        System.out.println(&quot;结束时间:&quot;+historicActivityInstance.getEndTime());
    }

}

}
</code></pre><p>说明：　　　</p>
<ul>
<li><p>在流程执行的过程中，创建的流程实例ID在整个过程中都不会变，当流程结束后，流程实例将会被删除</p>
</li>
<li><p>HistoricProcessInstance 包含当前和已经结束的流程实例信息。</p>
</li>
<li>HistoricActivityInstance 包含一个活动(流程上的节点)的执行信息 </li>
<li>processInstanceId查看具体某一次流程执行过程中所经历的步骤</li>
</ul>
<h2 id="流程变量添加（可添加javabean）"><a href="#流程变量添加（可添加javabean）" class="headerlink" title="流程变量添加（可添加javabean）"></a>流程变量添加（可添加javabean）</h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Activiti其核心是BPMN2.0 的流程引擎，是覆盖了业务流程管理、工作流、服务协作等领域的一个开源的、灵活的、易扩展的可执行流程语言框架&lt;br&gt;
    
    </summary>
    
      <category term="JavaEE" scheme="http://yoursite.com/categories/JavaEE/"/>
    
    
      <category term="Activiti" scheme="http://yoursite.com/tags/Activiti/"/>
    
      <category term="BPMN2.0" scheme="http://yoursite.com/tags/BPMN2-0/"/>
    
  </entry>
  
  <entry>
    <title>UEditor样式被过滤解决</title>
    <link href="http://yoursite.com/2017/06/21/UEditor%E6%A0%B7%E5%BC%8F%E8%A2%AB%E8%BF%87%E6%BB%A4%E8%A7%A3%E5%86%B3/"/>
    <id>http://yoursite.com/2017/06/21/UEditor样式被过滤解决/</id>
    <published>2017-06-21T06:34:34.000Z</published>
    <updated>2017-06-21T06:51:26.830Z</updated>
    
    <content type="html"><![CDATA[<p>前几天项目使用UEditor，结果发现class样式被过滤掉了，div标签也被自动替换成了p标签</p>
<a id="more"></a>
<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>前几天项目使用UEditor，结果发现class样式被过滤掉了，div标签也被自动替换成了p标签，也就是html内容无法正确显示，会被自动替换。</p>
<h1 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h1><p>1.在ueditor.all.js文件内找到如下代码     </p>
<pre><code>UE.plugins[&apos;defaultfilter&apos;] = function () {
var me = this;
me.setOpt({
    &apos;allowDivTransToP&apos;:true,
    &apos;disabledTableInTable&apos;:true
});
//默认的过滤处理
//进入编辑器的内容处理
me.addInputRule(function (root) {
    var allowDivTransToP = this.options.allowDivTransToP;
    var val;
    function tdParent(node){
        while(node &amp;&amp; node.type == &apos;element&apos;){
            if(node.tagName == &apos;td&apos;){
                return true;
            }
            node = node.parentNode;
        }
        return false;
    }
    //进行默认的处理
    root.traversal(function (node) {
        if (node.type == &apos;element&apos;) {
            if (!dtd.$cdata[node.tagName] &amp;&amp; me.options.autoClearEmptyNode &amp;&amp; dtd.$inline[node.tagName] &amp;&amp; !dtd.$empty[node.tagName] &amp;&amp; (!node.attrs || utils.isEmptyObject(node.attrs))) {
                if (!node.firstChild()) node.parentNode.removeChild(node);
                else if (node.tagName == &apos;span&apos; &amp;&amp; (!node.attrs || utils.isEmptyObject(node.attrs))) {
                    node.parentNode.removeChild(node, true)
                }
                return;
            }
            switch (node.tagName) {
                case &apos;style&apos;:
                case &apos;script&apos;:
                    node.setAttr({
                        cdata_tag: node.tagName,
                        cdata_data: (node.innerHTML() || &apos;&apos;),
                        &apos;_ue_custom_node_&apos;:&apos;true&apos;
                    });
                    node.tagName = &apos;div&apos;;
                    node.innerHTML(&apos;&apos;);
                    break;
                case &apos;a&apos;:
                    if (val = node.getAttr(&apos;href&apos;)) {
                        node.setAttr(&apos;_href&apos;, val)
                    }
                    break;
                //以下代码省略
</code></pre><p>2.把上面代码中的’allowDivTransToP’:true, 改成如下 </p>
<pre><code>me.setOpt({
    &apos;allowDivTransToP&apos;:false,
    &apos;disabledTableInTable&apos;:true
});
</code></pre><p>3.把 switch (node.tagName)中的case ‘style’:case ‘script’:注释掉，如下      </p>
<pre><code>switch (node.tagName) {
            //case &apos;style&apos;:
            /*case &apos;script&apos;:
                node.setAttr({
                    cdata_tag: node.tagName,
                    cdata_data: (node.innerHTML() || &apos;&apos;),
                    &apos;_ue_custom_node_&apos;:&apos;true&apos;
                });
                node.tagName = &apos;div&apos;;
                node.innerHTML(&apos;&apos;);
                break;
            */
            case &apos;a&apos;:
                if (val = node.getAttr(&apos;href&apos;)) {
                    node.setAttr(&apos;_href&apos;, val)
                }
                break;
            //以下代码省略
</code></pre><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><ul>
<li>allowDivTransToP设置为false是因为默认的设置是将div自动转换为p，这样写好的样式就找不到相应的div<br>了，所以才渲染不上的。</li>
<li>addInputRule函数中的switch 代码段中的case style ，script选择给删除或者注释，是为了避免出现编辑器style或script自动的转换成别的标签。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前几天项目使用UEditor，结果发现class样式被过滤掉了，div标签也被自动替换成了p标签&lt;/p&gt;
    
    </summary>
    
      <category term="JavaEE" scheme="http://yoursite.com/categories/JavaEE/"/>
    
    
      <category term="UEditor样式过滤" scheme="http://yoursite.com/tags/UEditor%E6%A0%B7%E5%BC%8F%E8%BF%87%E6%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>webmagic爬虫使用</title>
    <link href="http://yoursite.com/2017/06/20/webmagic%E7%88%AC%E8%99%AB%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2017/06/20/webmagic爬虫使用/</id>
    <published>2017-06-20T06:45:42.000Z</published>
    <updated>2017-06-21T07:31:12.362Z</updated>
    
    <content type="html"><![CDATA[<p>WebMagic是国内大牛开发的一款灵活开源的Java爬虫框架</p>
<a id="more"></a>
<p><img src="http://oje7mvhbz.bkt.clouddn.com/webmagic.png" alt="WebMagic"><br><a href="https://github.com/code4craft/webmagic" target="_blank" rel="external">github项目地址</a><br><a href="http://webmagic.io/docs/zh/" target="_blank" rel="external">官方中文文档</a></p>
<h1 id="简单入门"><a href="#简单入门" class="headerlink" title="简单入门"></a>简单入门</h1><p>WebMagic使用简单，而且中文文档介绍的也很详细，这篇博客主要介绍简单的使用，想要深入的话需要再研究</p>
<h2 id="编写基本爬虫"><a href="#编写基本爬虫" class="headerlink" title="编写基本爬虫"></a>编写基本爬虫</h2><h2 id="使用注解编写爬虫"><a href="#使用注解编写爬虫" class="headerlink" title="使用注解编写爬虫"></a>使用注解编写爬虫</h2><h1 id="使用WebMagic爬取新浪nba页面新闻"><a href="#使用WebMagic爬取新浪nba页面新闻" class="headerlink" title="使用WebMagic爬取新浪nba页面新闻"></a>使用WebMagic爬取新浪nba页面新闻</h1><pre><code>import us.codecraft.webmagic.Site;
import us.codecraft.webmagic.model.OOSpider;
import us.codecraft.webmagic.model.annotation.ExtractBy;
import us.codecraft.webmagic.model.annotation.HelpUrl;
import us.codecraft.webmagic.model.annotation.TargetUrl;
import us.codecraft.webmagic.pipeline.FilePageModelPipeline;


@TargetUrl(&quot;http://sports.sina.com.cn/basketball/nba/2017-06-19/doc-\\w+.shtml&quot;)
@HelpUrl(&quot;http://sports.sina.com.cn/&quot;)
public class NbaNews{

    @ExtractBy(value=&quot;//h1[@id=&apos;j_title&apos;]/text()&quot;,notNull=true)
    private String title;

    @ExtractBy(&quot;//section[@class=&apos;article-a_keywords&apos;]/a/text()&quot;)
    private String keywords;

    @ExtractBy(&quot;//div[@id=artibody]/tidyText()&quot;)
    private String content;



    public static void main(String[] args) {
        OOSpider.create(Site.me().setSleepTime(1000)
                , new FilePageModelPipeline(&quot;D:\\webmagic\\&quot;), NbaNews.class)
                .addUrl(&quot;http://sports.sina.com.cn/nba/&quot;).thread(5).run();
    }

}
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;WebMagic是国内大牛开发的一款灵活开源的Java爬虫框架&lt;/p&gt;
    
    </summary>
    
      <category term="JavaEE" scheme="http://yoursite.com/categories/JavaEE/"/>
    
    
      <category term="WebMagic" scheme="http://yoursite.com/tags/WebMagic/"/>
    
      <category term="爬虫" scheme="http://yoursite.com/tags/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>Ueditor使用</title>
    <link href="http://yoursite.com/2017/06/14/Ueditor%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2017/06/14/Ueditor使用/</id>
    <published>2017-06-14T10:12:41.000Z</published>
    <updated>2017-06-14T10:54:38.593Z</updated>
    
    <content type="html"><![CDATA[<p>UEditor和springMVC整合上传图片</p>
<a id="more"></a>
<p><a href="http://ueditor.baidu.com/website/" target="_blank" rel="external">UEditro官网</a><br><a href="http://fex.baidu.com/ueditor/#start-start" target="_blank" rel="external">官方文档</a></p>
<h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h3><p>提供了各种版本的下载，我下载的是jsp版本的，当然你也可以下载完整源码，一样的使用，<strong>注意版本，不同的版本使用方法可能有些不同</strong><br><img src="http://oje7mvhbz.bkt.clouddn.com/GD%5DADT7L~%29Q%7B6_1%5BTGJ%29%5B%5DF.png" alt="下载UEditor"></p>
<h3 id="导入项目"><a href="#导入项目" class="headerlink" title="导入项目"></a>导入项目</h3><p>把所有下载的包解压后，导入项目中。<strong>并把/jsp/lib文件夹下的jar包添加到pom.xml中</strong><br><img src="http://oje7mvhbz.bkt.clouddn.com/06%5D36C5@P4P3G0@0Q5X%7DB56.png" alt="导入项目中"></p>
<h3 id="在需要使用的页面引入js和css"><a href="#在需要使用的页面引入js和css" class="headerlink" title="在需要使用的页面引入js和css"></a>在需要使用的页面引入js和css</h3><pre><code>&lt;script type=&quot;text/javascript&quot; src=&quot;/js/ueditor/ueditor.config.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot; src=&quot;/js/ueditor/ueditor.all.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot; charset=&quot;utf-8&quot; src=&quot;/js/ueditor/lang/zh-cn/zh-cn.js&quot;&gt;&lt;/script&gt;
&lt;link href=&quot;/js/ueditor/themes/default/css/ueditor.css&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot; /&gt;
</code></pre><h3 id="在页面js中实例化UE"><a href="#在页面js中实例化UE" class="headerlink" title="在页面js中实例化UE"></a>在页面js中实例化UE</h3><pre><code>/*富文本编辑器*/
var editor = UE.getEditor(&apos;content&apos;);

UE.Editor.prototype._bkGetActionUrl = UE.Editor.prototype.getActionUrl;

UE.Editor.prototype.getActionUrl = function(action) {

if (action == &apos;uploadimage&apos; || action == &apos;uploadscrawl&apos; || action == &apos;catchimage&apos;
    || action == &apos;uploadimage&apos;) {
        return basePath+&apos;/uploadimage.html&apos;;
}else {
        return this._bkGetActionUrl.call(this, action);
    }
}
</code></pre><h3 id="如果你的jsp文件夹没有移动过位置就不需要配置uditor-config-js和controller中的路径"><a href="#如果你的jsp文件夹没有移动过位置就不需要配置uditor-config-js和controller中的路径" class="headerlink" title="如果你的jsp文件夹没有移动过位置就不需要配置uditor.config.js和controller中的路径"></a>如果你的jsp文件夹没有移动过位置就不需要配置uditor.config.js和controller中的路径</h3><h3 id="配置uditor-config-js自定义工具栏"><a href="#配置uditor-config-js自定义工具栏" class="headerlink" title="配置uditor.config.js自定义工具栏"></a>配置uditor.config.js自定义工具栏</h3><pre><code>toolbars: [
[
    &apos;anchor&apos;, //锚点
    &apos;undo&apos;, //撤销
    &apos;redo&apos;, //重做
    &apos;bold&apos;, //加粗
    &apos;indent&apos;, //首行缩进
    &apos;snapscreen&apos;, //截图
    &apos;italic&apos;, //斜体
    &apos;underline&apos;, //下划线
    &apos;strikethrough&apos;, //删除线
    &apos;subscript&apos;, //下标
    &apos;fontborder&apos;, //字符边框
    &apos;superscript&apos;, //上标
    &apos;formatmatch&apos;, //格式刷
    &apos;source&apos;, //源代码
    &apos;blockquote&apos;, //引用
    &apos;pasteplain&apos;, //纯文本粘贴模式
    &apos;selectall&apos;, //全选
    &apos;print&apos;, //打印
    &apos;preview&apos;, //预览
    &apos;horizontal&apos;, //分隔线
    &apos;removeformat&apos;, //清除格式
    &apos;time&apos;, //时间
    &apos;date&apos;, //日期
    &apos;unlink&apos;, //取消链接
    &apos;insertrow&apos;, //前插入行
    &apos;insertcol&apos;, //前插入列
    &apos;mergeright&apos;, //右合并单元格
    &apos;mergedown&apos;, //下合并单元格
    &apos;deleterow&apos;, //删除行
    &apos;deletecol&apos;, //删除列
    &apos;splittorows&apos;, //拆分成行
    &apos;splittocols&apos;, //拆分成列
    &apos;splittocells&apos;, //完全拆分单元格
    &apos;deletecaption&apos;, //删除表格标题
    &apos;inserttitle&apos;, //插入标题
    &apos;mergecells&apos;, //合并多个单元格
    &apos;deletetable&apos;, //删除表格
    &apos;cleardoc&apos;, //清空文档
    &apos;insertparagraphbeforetable&apos;, //&quot;表格前插入行&quot;
    &apos;insertcode&apos;, //代码语言
    &apos;fontfamily&apos;, //字体
    &apos;fontsize&apos;, //字号
    &apos;paragraph&apos;, //段落格式
    &apos;simpleupload&apos;, //单图上传
    &apos;insertimage&apos;, //多图上传
    &apos;edittable&apos;, //表格属性
    &apos;edittd&apos;, //单元格属性
    &apos;link&apos;, //超链接
    &apos;emotion&apos;, //表情
    &apos;spechars&apos;, //特殊字符
    &apos;searchreplace&apos;, //查询替换
    &apos;map&apos;, //Baidu地图
    &apos;gmap&apos;, //Google地图
    &apos;insertvideo&apos;, //视频
    &apos;help&apos;, //帮助
    &apos;justifyleft&apos;, //居左对齐
    &apos;justifyright&apos;, //居右对齐
    &apos;justifycenter&apos;, //居中对齐
    &apos;justifyjustify&apos;, //两端对齐
    &apos;forecolor&apos;, //字体颜色
    &apos;backcolor&apos;, //背景色
    &apos;insertorderedlist&apos;, //有序列表
    &apos;insertunorderedlist&apos;, //无序列表
    &apos;fullscreen&apos;, //全屏
    &apos;directionalityltr&apos;, //从左向右输入
    &apos;directionalityrtl&apos;, //从右向左输入
    &apos;rowspacingtop&apos;, //段前距
    &apos;rowspacingbottom&apos;, //段后距
    &apos;pagebreak&apos;, //分页
    &apos;insertframe&apos;, //插入Iframe
    &apos;imagenone&apos;, //默认
    &apos;imageleft&apos;, //左浮动
    &apos;imageright&apos;, //右浮动
    &apos;attachment&apos;, //附件
    &apos;imagecenter&apos;, //居中
    &apos;wordimage&apos;, //图片转存
    &apos;lineheight&apos;, //行间距
    &apos;edittip &apos;, //编辑提示
    &apos;customstyle&apos;, //自定义标题
    &apos;autotypeset&apos;, //自动排版
    &apos;webapp&apos;, //百度应用
    &apos;touppercase&apos;, //字母大写
    &apos;tolowercase&apos;, //字母小写
    &apos;background&apos;, //背景
    &apos;template&apos;, //模板
    &apos;scrawl&apos;, //涂鸦
    &apos;music&apos;, //音乐
    &apos;inserttable&apos;, //插入表格
    &apos;drafts&apos;, // 从草稿箱加载
    &apos;charts&apos;, // 图表
    ]
]
</code></pre><h3 id="配置config-json，这里列举一个配置，其他一样配置imagePathFormat和imageUrlPrefix一定不能错"><a href="#配置config-json，这里列举一个配置，其他一样配置imagePathFormat和imageUrlPrefix一定不能错" class="headerlink" title="配置config.json，这里列举一个配置，其他一样配置imagePathFormat和imageUrlPrefix一定不能错"></a>配置config.json，这里列举一个配置，其他一样配置imagePathFormat和imageUrlPrefix一定不能错</h3><pre><code>/* 前后端通信相关的配置,注释只允许使用多行方式 */
{
/* 上传图片配置项 */
&quot;imageActionName&quot;: &quot;uploadimage&quot;, /* 执行上传图片的action名称 */
&quot;imageFieldName&quot;: &quot;upfile&quot;, /* 提交的图片表单名称 */
&quot;imageMaxSize&quot;: 2048000, /* 上传大小限制，单位B */
&quot;imageAllowFiles&quot;: [&quot;.png&quot;, &quot;.jpg&quot;, &quot;.jpeg&quot;, &quot;.gif&quot;, &quot;.bmp&quot;], /* 上传图片格式显示 */
&quot;imageCompressEnable&quot;: true, /* 是否压缩图片,默认是true */
&quot;imageCompressBorder&quot;: 1600, /* 图片压缩最长边限制 */
&quot;imageInsertAlign&quot;: &quot;none&quot;, /* 插入的图片浮动方式 */
&quot;imageUrlPrefix&quot;: &quot;&quot;, /* 图片访问路径前缀 */
&quot;imagePathFormat&quot;: &quot;/ueditor/jsp/upload/image/{yyyy}{mm}{dd}/{time}{rand:6}&quot;, /* 上传保存路径,可以自定义保存路径和文件名格式 */
                            /* {filename} 会替换成原文件名,配置这项需要注意中文乱码问题 */
                            /* {rand:6} 会替换成随机数,后面的数字是随机数的位数 */
                            /* {time} 会替换成时间戳 */
                            /* {yyyy} 会替换成四位年份 */
                            /* {yy} 会替换成两位年份 */
                            /* {mm} 会替换成两位月份 */
                            /* {dd} 会替换成两位日期 */
                            /* {hh} 会替换成两位小时 */
                            /* {ii} 会替换成两位分钟 */
                            /* {ss} 会替换成两位秒 */
                            /* 非法字符 \ : * ? &quot; &lt; &gt; | */
                            /* 具请体看线上文档: fex.baidu.com/ueditor/#use-format_upload_filename */
}
</code></pre><p><strong>imageUrlPrefix：</strong> 这个一般是项目url，比如www.baidu.com<br><strong>imagePathFormat：</strong> 和上传路劲中的一致就可以了</p>
<h3 id="我使用的是springMVC实现上传，只有当返回的json中state的值为SUCCESS才上传成功，上传失败则回显state的值"><a href="#我使用的是springMVC实现上传，只有当返回的json中state的值为SUCCESS才上传成功，上传失败则回显state的值" class="headerlink" title="我使用的是springMVC实现上传，只有当返回的json中state的值为SUCCESS才上传成功，上传失败则回显state的值"></a>我使用的是springMVC实现上传，只有当返回的json中state的值为SUCCESS才上传成功，上传失败则回显state的值</h3><pre><code>@ResponseBody  
@RequestMapping(value = &quot;/uploadimage.html&quot;)  
public Map&lt;String,Object&gt; uploadImage(@RequestParam(&quot;upfile&quot;) MultipartFile[] multipartFiles, HttpServletRequest request, HttpServletResponse response) {  
    //存放地址  
    String filepath = &quot;&quot;;
    Map&lt;String,Object&gt; map=new HashMap&lt;String,Object&gt;();
    //对上传文件进行安全性验证
    if(multipartFiles!=null &amp;&amp; multipartFiles.length&gt;0){
        //循环遍历
        for (MultipartFile multipartFile : multipartFiles) {
            String state=&quot;SUCCESS&quot;;
            if (CheckoutFileTypeUtil.getUpFilelegitimacyFlag(multipartFile)) {
                try {
                    filepath = UploadUtil.uploadUeFile(multipartFile);
                    if (logger.isDebugEnabled()) {
                        logger.debug(&quot;上传成功---------------------&quot;+filepath+&quot;上传成功---------------------&quot;);
                    }
                    //注意url会和conf.json中的路径配合找到图片
                    map.put(&quot;url&quot;, filepath);
                    map.put(&quot;state&quot;, &quot;SUCCESS&quot;);
                } catch (IOException e) {
                    logger.debug(&quot;图片上传失败&quot;);
                    e.printStackTrace(); 
                }
            }else {
                    map.put(&quot;state&quot;, &quot;上传失败!&quot;);
                    map.put(&quot;url&quot;, null);
                if (logger.isDebugEnabled()) {
                    logger.debug(&quot;图片格式不对,上传失败!&quot;);
                }
            }
        }
    }
    return map;
} 
</code></pre><h3 id="对上传的文件进行后端安全性验证，验证文件的魔数和格式，防止黑客绕过前端上传木马"><a href="#对上传的文件进行后端安全性验证，验证文件的魔数和格式，防止黑客绕过前端上传木马" class="headerlink" title="对上传的文件进行后端安全性验证，验证文件的魔数和格式，防止黑客绕过前端上传木马"></a>对上传的文件进行后端安全性验证，验证文件的魔数和格式，防止黑客绕过前端上传木马</h3><pre><code>    /**
     * 
     * @Description: 处理上传附件,校验是否合法
     * 在服务器端判断文件类型的问题，故用获取文件头的方式，
     * 直接读取文件的前几个字节，来判断上传文件是否符合格式
     */
public class CheckoutFileTypeUtil {
    //记录各个文件头信息及对应的文件类型
    public static Map&lt;String, String&gt; mFileTypes = new HashMap&lt;String, String&gt;();

    //所有合法的文件后缀
    public static String res_fileType=&quot;.jpg.png.gif.bmp&quot;;

    static {
        // images          
            mFileTypes.put(&quot;FFD8FFE0&quot;, &quot;.jpg&quot;);
            mFileTypes.put(&quot;FFD8FFE1&quot;, &quot;.jpg&quot;);
        mFileTypes.put(&quot;89504E47&quot;, &quot;.png&quot;);
        mFileTypes.put(&quot;47494638&quot;, &quot;.gif&quot;);
        mFileTypes.put(&quot;49492A00&quot;, &quot;.tif&quot;);
        mFileTypes.put(&quot;424D&quot;, &quot;.bmp&quot;);

        //PS和CAD
        mFileTypes.put(&quot;38425053&quot;, &quot;.psd&quot;);
        mFileTypes.put(&quot;41433130&quot;, &quot;.dwg&quot;); // CAD
        mFileTypes.put(&quot;252150532D41646F6265&quot;,&quot;.ps&quot;);

        //办公文档类
        mFileTypes.put(&quot;D0CF11E0&quot;, &quot;.doc&quot;); //ppt、doc、xls
        mFileTypes.put(&quot;504B0304&quot;, &quot;.docx&quot;);//pptx、docx、xlsx   

        /**注意由于文本文档录入内容过多，则读取文件头时较为多变-START**/
        mFileTypes.put(&quot;0D0A0D0A&quot;, &quot;.txt&quot;);//txt
            mFileTypes.put(&quot;0D0A2D2D&quot;, &quot;.txt&quot;);//txt
        mFileTypes.put(&quot;0D0AB4B4&quot;, &quot;.txt&quot;);//txt       
        mFileTypes.put(&quot;B4B4BDA8&quot;, &quot;.txt&quot;);//文件头部为汉字
        mFileTypes.put(&quot;73646673&quot;, &quot;.txt&quot;);//txt,文件头部为英文字母
        mFileTypes.put(&quot;32323232&quot;, &quot;.txt&quot;);//txt,文件头部内容为数字
        mFileTypes.put(&quot;0D0A09B4&quot;, &quot;.txt&quot;);//txt,文件头部内容为数字
        mFileTypes.put(&quot;3132330D&quot;, &quot;.txt&quot;);//txt,文件头部内容为数字     
        /**注意由于文本文档录入内容过多，则读取文件头时较为多变-END**/


        mFileTypes.put(&quot;7B5C727466&quot;, &quot;.rtf&quot;); // 日记本

        mFileTypes.put(&quot;255044462D312E&quot;, &quot;.pdf&quot;);

        //视频或音频类
        mFileTypes.put(&quot;3026B275&quot;,&quot;.wma&quot;);
        mFileTypes.put(&quot;57415645&quot;, &quot;.wav&quot;);
        mFileTypes.put(&quot;41564920&quot;, &quot;.avi&quot;);
        mFileTypes.put(&quot;4D546864&quot;, &quot;.mid&quot;);
        mFileTypes.put(&quot;2E524D46&quot;, &quot;.rm&quot;);
        mFileTypes.put(&quot;000001BA&quot;, &quot;.mpg&quot;);
            mFileTypes.put(&quot;000001B3&quot;, &quot;.mpg&quot;);
        mFileTypes.put(&quot;6D6F6F76&quot;, &quot;.mov&quot;);
        mFileTypes.put(&quot;3026B2758E66CF11&quot;, &quot;.asf&quot;);

        //压缩包
        mFileTypes.put(&quot;52617221&quot;, &quot;.rar&quot;);    
        mFileTypes.put(&quot;1F8B08&quot;, &quot;.gz&quot;);

        //程序文件
        mFileTypes.put(&quot;3C3F786D6C&quot;, &quot;.xml&quot;);
        mFileTypes.put(&quot;68746D6C3E&quot;, &quot;.html&quot;);
        mFileTypes.put(&quot;7061636B&quot;, &quot;.java&quot;);
        mFileTypes.put(&quot;3C254020&quot;, &quot;.jsp&quot;);
        mFileTypes.put(&quot;4D5A9000&quot;, &quot;.exe&quot;);        


        mFileTypes.put(&quot;44656C69766572792D646174653A&quot;, &quot;.eml&quot;); // 邮件
        mFileTypes.put(&quot;5374616E64617264204A&quot;, &quot;.mdb&quot;);//Access数据库文件

        mFileTypes.put(&quot;46726F6D&quot;, &quot;.mht&quot;);
        mFileTypes.put(&quot;4D494D45&quot;, &quot;.mhtml&quot;);


    }



    /**
     * 根据文件的输入流获取文件头信息
     *
     * @param filePath 文件路径
     * @return 文件头信息
     */
    public static String getFileType(InputStream  is) {
        byte[] b = new byte[4];
        if(is!=null){
            try {
                is.read(b, 0, b.length);
            } catch (IOException e) {
                e.printStackTrace();
            }
        }              

       return mFileTypes.get(getFileHeader(b));
    }


    /**
     * 根据文件转换成的字节数组获取文件头信息
     *
     * @param filePath
     *            文件路径
     * @return 文件头信息
     */
    public static String getFileHeader(byte[] b) {     
    String value = bytesToHexString(b);
    return value;
}

/**
 * 
 * 将要读取文件头信息的文件的byte数组转换成string类型表示
 * 下面这段代码就是用来对文件类型作验证的方法，
 * 将字节数组的前四位转换成16进制字符串，并且转换的时候，要先和0xFF做一次与运算。
 * 这是因为，整个文件流的字节数组中，有很多是负数，进行了与运算后，可以将前面的符号位都去掉，
 * 这样转换成的16进制字符串最多保留两位，如果是正数又小于10，那么转换后只有一位，
 * 需要在前面补0，这样做的目的是方便比较，取完前四位这个循环就可以终止了
 * @param src要读取文件头信息的文件的byte数组
 * @return 文件头信息
 */
private static String bytesToHexString(byte[] src) {
    StringBuilder builder = new StringBuilder();
    if (src == null || src.length &lt;= 0) {
        return null;
    }
    String hv;
    for (int i = 0; i &lt; src.length; i++) {
        // 以十六进制（基数 16）无符号整数形式返回一个整数参数的字符串表示形式，并转换为大写
        hv = Integer.toHexString(src[i] &amp; 0xFF).toUpperCase();
        if (hv.length() &lt; 2) {
            builder.append(0);
        }
        builder.append(hv);
    }

    System.out.println(&quot;获取文件头信息:&quot;+builder.toString());

    return builder.toString();
}


/**
 * cjf
 * 判断上传的文件是否合法
 * （一）、第一：检查文件的扩展名，
 * (二）、 第二：检查文件的MIME类型 。
 * @param attachDoc
 * @return boolean
 */
public static boolean getUpFilelegitimacyFlag(MultipartFile picFile){
    boolean upFlag=false;//为真表示符合上传条件，为假表标不符合
    if(picFile !=null){           
        String picName = picFile.getOriginalFilename();

        System.out.println(&quot;#######上传的文件:&quot;+picName);

        if(!&quot;&quot;.equals(picName)&amp;&amp;picName!=null){

            /**返回在此字符串中最右边出现的指定子字符串的索引   **/                             
            String pname = picName.substring(picName.lastIndexOf(&quot;.&quot;));

            /**统一转换为小写**/
            pname=pname.toLowerCase();

            /**第一步：检查文件扩展名，是否符合要求范围**/
            if(res_fileType.indexOf(pname)!=-1){
                upFlag=true;
            }

            /**
             * 第二步：获取上传附件的文件头，判断属于哪种类型,并获取其扩展名         
             * 直接读取文件的前几个字节，来判断上传文件是否符合格式
             * 防止上传附件变更扩展名绕过校验
             ***/    
            if(upFlag){

                byte[] b = new byte[4];

                String req_fileType = null;
                try {
                    req_fileType = getFileType(picFile.getInputStream());
                } catch (IOException e) {
                    // TODO Auto-generated catch block
                    e.printStackTrace();
                }                  
                System.out.println(&quot;///////用户上传的文件类型///////////&quot;+req_fileType);
                /**第三步：检查文件扩展名，是否符合要求范围**/
                if(req_fileType!=null &amp;&amp; !&quot;&quot;.equals(req_fileType) &amp;&amp; !&quot;null&quot;.equals(req_fileType)){
                    /**第四步：校验上传的文件扩展名，是否在其规定范围内**/
                    if(res_fileType.indexOf(req_fileType)!=-1){                    
                        upFlag=true;
                    }else{
                        upFlag=false;
                    }
                }else{
                    /**特殊情况校验,如果用户上传的扩展名为,文本文件,则允许上传-START**/
                    if(pname.indexOf(&quot;.txt&quot;)!=-1){
                        upFlag=true;
                    }else{
                        upFlag=false;
                    }
                    /**特殊情况校验,如果用户上传的扩展名为,文本文件,则允许上传-END**/
                }
            }                                      
        }      
    }
    return upFlag;
}
}
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;UEditor和springMVC整合上传图片&lt;/p&gt;
    
    </summary>
    
      <category term="JavaEE" scheme="http://yoursite.com/categories/JavaEE/"/>
    
    
      <category term="UEditor" scheme="http://yoursite.com/tags/UEditor/"/>
    
      <category term="文件上传安全性验证" scheme="http://yoursite.com/tags/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E5%AE%89%E5%85%A8%E6%80%A7%E9%AA%8C%E8%AF%81/"/>
    
  </entry>
  
  <entry>
    <title>各种历史版本下载</title>
    <link href="http://yoursite.com/2017/06/02/%E5%90%84%E7%A7%8D%E5%8E%86%E5%8F%B2%E7%89%88%E6%9C%AC%E4%B8%8B%E8%BD%BD/"/>
    <id>http://yoursite.com/2017/06/02/各种历史版本下载/</id>
    <published>2017-06-02T08:59:58.000Z</published>
    <updated>2017-06-02T09:09:58.533Z</updated>
    
    <content type="html"><![CDATA[<p>jdk、Tomcat、eclipse历史版本下载链接<br><a id="more"></a><br><a href="http://archive.apache.org/dist/tomcat/" target="_blank" rel="external">tomcat历史版本下载</a><br><a href="http://www.oracle.com/technetwork/Java/javase/downloads/index.html" target="_blank" rel="external">JDK历史版本下载</a><br><a href="http://wiki.eclipse.org/Older_Versions_Of_Eclipse" target="_blank" rel="external">eclipse历史版本下载</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;jdk、Tomcat、eclipse历史版本下载链接&lt;br&gt;
    
    </summary>
    
      <category term="其他" scheme="http://yoursite.com/categories/%E5%85%B6%E4%BB%96/"/>
    
    
      <category term="历史版本下载" scheme="http://yoursite.com/tags/%E5%8E%86%E5%8F%B2%E7%89%88%E6%9C%AC%E4%B8%8B%E8%BD%BD/"/>
    
  </entry>
  
  <entry>
    <title>判断ip是否合法</title>
    <link href="http://yoursite.com/2017/05/26/%E5%88%A4%E6%96%ADip%E6%98%AF%E5%90%A6%E5%90%88%E6%B3%95/"/>
    <id>http://yoursite.com/2017/05/26/判断ip是否合法/</id>
    <published>2017-05-26T07:56:50.000Z</published>
    <updated>2017-05-26T08:02:04.427Z</updated>
    
    <content type="html"><![CDATA[<p>自用笔记<br><a id="more"></a><br>java中使用正则表达式校验ip是否合法</p>
<pre><code>public static boolean isIPAddress(String ip) {
    boolean isIP = false;
    Pattern pattern = Pattern.compile(&quot;\\b((?!\\d\\d\\d)\\d+|1\\d\\d|2[0-4]\\d|25[0-5])\\.((?!\\d\\d\\d)\\d+|1\\d\\d|2[0-4]\\d|25[0-5])\\.((?!\\d\\d\\d)\\d+|1\\d\\d|2[0-4]\\d|25[0-5])\\.((?!\\d\\d\\d)\\d+|1\\d\\d|2[0-4]\\d|25[0-5])\\b&quot;);
    Matcher m = pattern.matcher(ip);
    isIP = m.matches();
    return isIP;
}
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;自用笔记&lt;br&gt;
    
    </summary>
    
      <category term="JavaEE" scheme="http://yoursite.com/categories/JavaEE/"/>
    
    
      <category term="ip校验" scheme="http://yoursite.com/tags/ip%E6%A0%A1%E9%AA%8C/"/>
    
  </entry>
  
  <entry>
    <title>nginx+ssl配置https</title>
    <link href="http://yoursite.com/2017/05/16/nginx-ssl%E9%85%8D%E7%BD%AEhttps/"/>
    <id>http://yoursite.com/2017/05/16/nginx-ssl配置https/</id>
    <published>2017-05-16T10:02:17.000Z</published>
    <updated>2017-05-16T10:22:27.020Z</updated>
    
    <content type="html"><![CDATA[<p>因工作需要，试着配了下nginx+ssl配置https,被nginx版本问题坑的要死。。。。<br><a id="more"></a></p>
<h1 id="确保nginx支持ssl"><a href="#确保nginx支持ssl" class="headerlink" title="确保nginx支持ssl"></a>确保nginx支持ssl</h1><p>nginx编译时带 –with-http_ssl_module 参数，否则后面加入ssl配置时会报以下错</p>
<pre><code>[emerg] 10464#0: unknown directive &quot;ssl&quot; in /usr/local/nginx/conf/nginx.conf:118”
</code></pre><h1 id="使用openssl颁发证书"><a href="#使用openssl颁发证书" class="headerlink" title="使用openssl颁发证书"></a>使用openssl颁发证书</h1><p>创建服务端私钥</p>
<pre><code>cd /usr/local/nginx/
mkdir ssl
cd ssl
openssl genrsa -des3 -out server.key 2048
</code></pre><p>创建证书请求文件,然后按要求依次输入密码、国家代码、省份城市、邮箱等信息</p>
<pre><code>openssl req -new -nodes -sha256 -key server.key -out server.csr
</code></pre><p>去除私钥里的密码信息</p>
<pre><code>openssl rsa -in server.key -out server_nopwd.key
</code></pre><p>使用刚生成的私钥和CSR进行证书签名</p>
<pre><code>openssl x509 -req -days 3650 -sha256 -in server.csr -signkey server_nopwd.key -out server.crt
</code></pre><h1 id="修改nginx配置文件"><a href="#修改nginx配置文件" class="headerlink" title="修改nginx配置文件"></a>修改nginx配置文件</h1><pre><code>server {
        listen       443 ssl;
        server_name  localhost;

        ssl_certificate      /usr/local/nginx/ssl/server.crt;
        ssl_certificate_key  /usr/local/nginx/ssl/server_nopwd.key;

        #ssl_session_cache    shared:SSL:1m;
        ssl_session_timeout  5m;

        ssl_protocols TLSv1.2 TLSv1.1 TLSv1;
        ssl_prefer_server_ciphers on;
        ssl_ciphers EECDH+AESGCM:EDH+AESGCM:AES256+EECDH:AES256+EDH;

        location /{
               #root   /usr/local/nginx/html80;
               proxy_pass http://myServer;

        }
    }
</code></pre><p><strong> 注：配置完成后的网站路径及默认页等配置请与80端口保持一致。</strong></p>
<h1 id="访问页面"><a href="#访问页面" class="headerlink" title="访问页面"></a>访问页面</h1><ul>
<li><p>线上：  启动nginx，访问https：//+证书绑定的域名    </p>
</li>
<li><p>本地测试： 如果本地测试，请做本地解析访问：打开  系统盘:\Windows\System32\Drivers\etc\hosts 文件，用文本编辑器修改，把证书绑定的域名解析到本地ip。</p>
</li>
<li><p>浏览器添加信任证书   </p>
</li>
<li>防火墙设置-例外端口-添加443端口（TCP）</li>
</ul>
<h1 id="无法连接错误解决"><a href="#无法连接错误解决" class="headerlink" title="无法连接错误解决"></a>无法连接错误解决</h1><h3 id="把443端口的server提到80端口前面，我试了之后还没有解决。。。。。"><a href="#把443端口的server提到80端口前面，我试了之后还没有解决。。。。。" class="headerlink" title="把443端口的server提到80端口前面，我试了之后还没有解决。。。。。"></a>把443端口的server提到80端口前面，我试了之后还没有解决。。。。。</h3><h3 id="查资料，发现需要在443监听端口后面加ssl"><a href="#查资料，发现需要在443监听端口后面加ssl" class="headerlink" title="查资料，发现需要在443监听端口后面加ssl"></a>查资料，发现需要在443监听端口后面加ssl</h3><pre><code>listen 443; &gt;&gt;&gt; listen 443 ssl;
</code></pre><p>原因是listen 443这种写法是支持新版本而不支持老版本的。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;因工作需要，试着配了下nginx+ssl配置https,被nginx版本问题坑的要死。。。。&lt;br&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
    
      <category term="https" scheme="http://yoursite.com/tags/https/"/>
    
  </entry>
  
  <entry>
    <title>多机部署hexo博客</title>
    <link href="http://yoursite.com/2017/05/15/%E5%A4%9A%E6%9C%BA%E9%83%A8%E7%BD%B2hexo%E5%8D%9A%E5%AE%A2/"/>
    <id>http://yoursite.com/2017/05/15/多机部署hexo博客/</id>
    <published>2017-05-15T10:34:16.000Z</published>
    <updated>2017-05-16T00:34:29.873Z</updated>
    
    <content type="html"><![CDATA[<p>因为想公司电脑和家里电脑同时可以操作hexo博客<br><a id="more"></a></p>
<h3 id="下载git，添加GitHub密钥"><a href="#下载git，添加GitHub密钥" class="headerlink" title="下载git，添加GitHub密钥"></a>下载git，添加GitHub密钥</h3><h3 id="下载node-js"><a href="#下载node-js" class="headerlink" title="下载node.js"></a>下载node.js</h3><h3 id="原bolg文件夹复制过新电脑"><a href="#原bolg文件夹复制过新电脑" class="headerlink" title="原bolg文件夹复制过新电脑"></a>原bolg文件夹复制过新电脑</h3><h3 id="删除-git-，node-modules-，public-，-deploy-git-，db-json文件"><a href="#删除-git-，node-modules-，public-，-deploy-git-，db-json文件" class="headerlink" title="删除.git/，node_modules/，public/，.deploy_git/，db.json文件"></a>删除.git/，node_modules/，public/，.deploy_git/，db.json文件</h3><h3 id="安装hexo-不需要hexo-init"><a href="#安装hexo-不需要hexo-init" class="headerlink" title="安装hexo(不需要hexo init)"></a>安装hexo(不需要hexo init)</h3><pre><code>npm install hexo
npm install
npm install hexo-deployer-git --save
</code></pre><h3 id="部署到GitHub上"><a href="#部署到GitHub上" class="headerlink" title="部署到GitHub上"></a>部署到GitHub上</h3><pre><code>hexo g -d
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;因为想公司电脑和家里电脑同时可以操作hexo博客&lt;br&gt;
    
    </summary>
    
      <category term="博客相关" scheme="http://yoursite.com/categories/%E5%8D%9A%E5%AE%A2%E7%9B%B8%E5%85%B3/"/>
    
    
      <category term="多机部署博客" scheme="http://yoursite.com/tags/%E5%A4%9A%E6%9C%BA%E9%83%A8%E7%BD%B2%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
  <entry>
    <title>Linux上部署多个Tomcat</title>
    <link href="http://yoursite.com/2017/04/30/Linux%E4%B8%8A%E9%83%A8%E7%BD%B2%E5%A4%9A%E4%B8%AATomcat/"/>
    <id>http://yoursite.com/2017/04/30/Linux上部署多个Tomcat/</id>
    <published>2017-04-30T01:00:39.000Z</published>
    <updated>2017-05-26T08:29:35.038Z</updated>
    
    <content type="html"><![CDATA[<p>自用笔记<br><a id="more"></a></p>
<ul>
<li>修改Tomcat的端口号</li>
<li><p>修改/etc/profile环境变量</p>
<pre><code>export JAVA_HOME=/usr/java/jdk1.7.0_79
export CLASSPATH=.:$JAVA_HOME/jre/lib/rt.jar:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar
export PATH=$PATH:$JAVA_HOME/bin

#tomcat0  
CATALINA_0_BASE=/usr/local/server/tomcat0  
CATALINA_0_HOME=/usr/local/server/tomcat0  
export CATALINA_0_BASE CATALINA_0_HOME  

# tomcat1  
CATALINA_1_BASE=/usr/local/server/tomcat1 
CATALINA_1_HOME=/usr/local/server/tomcatc1   
export CATALINA_2_BASE CATALINA_2_HOME 

#tomcat2
CATALINA_2_BASE=/usr/local/server/tomcat2 
CATALINA_2_HOME=/usr/local/server/tomcat2  
export CATALINA_2_BASE CATALINA_2_HOME

TOMCAT_0_HOME=/usr/local/server/tomcat0  
export TOMCAT_0_HOME  

TOMCAT_1_HOME=/usr/local/server/tomcat1  
export TOMCAT_1_HOME

TOMCAT_2_HOME=/usr/local/server/tomcat2
export TOMCAT_2_HOME    

#log out service while timeout
export TMOUT=900
readonly TMOUT
</code></pre></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;自用笔记&lt;br&gt;
    
    </summary>
    
      <category term="JavaEE" scheme="http://yoursite.com/categories/JavaEE/"/>
    
    
      <category term="Linux部署多个Tomcat" scheme="http://yoursite.com/tags/Linux%E9%83%A8%E7%BD%B2%E5%A4%9A%E4%B8%AATomcat/"/>
    
  </entry>
  
  <entry>
    <title>nginx负载均衡配置</title>
    <link href="http://yoursite.com/2017/04/30/nginx%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E9%85%8D%E7%BD%AE/"/>
    <id>http://yoursite.com/2017/04/30/nginx负载均衡配置/</id>
    <published>2017-04-30T00:52:15.000Z</published>
    <updated>2017-04-30T01:55:53.546Z</updated>
    
    <content type="html"><![CDATA[<p>自用学习笔记<br><a id="more"></a><br>Nginx是一款高性能的http 服务器/反向代理服务器及电子邮件（IMAP/POP3）代理服务器。由俄罗斯的程序设计师Igor Sysoev所开发，官方测试nginx能够支支撑5万并发链接，并且cpu、内存等资源消耗却非常低，运行非常稳定。</p>
<h1 id="Nginx安装"><a href="#Nginx安装" class="headerlink" title="Nginx安装"></a>Nginx安装</h1><h3 id="安装环境"><a href="#安装环境" class="headerlink" title="安装环境"></a>安装环境</h3><ul>
<li><p>gcc</p>
<pre><code>yum install gcc-c++ 
</code></pre></li>
<li><p>PCRE    </p>
<pre><code>yum install -y pcre pcre-devel
</code></pre></li>
<li><p>zlib</p>
<pre><code>yum install -y zlib zlib-devel
</code></pre></li>
<li><p>openssl</p>
<pre><code>yum install -y openssl openssl-devel
</code></pre></li>
</ul>
<h3 id="编译安装"><a href="#编译安装" class="headerlink" title="编译安装"></a>编译安装</h3><ol>
<li>解压</li>
<li>配置</li>
<li>编译安装<h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3><pre><code>cd /usr/local/nginx/sbin/
./nginx
</code></pre></li>
</ol>
<p>或者指定加载配置文件启动</p>
<pre><code>./nginx -c /usr/local/nginx/conf/nginx.conf
</code></pre><h3 id="停止"><a href="#停止" class="headerlink" title="停止"></a>停止</h3><p>方式一：快速停止，相当于kill进程</p>
<pre><code>cd /usr/local/nginx/sbin
./nginx -s stop
</code></pre><p>方式二：待nginx进程处理完毕任务后停止（推荐）</p>
<pre><code>cd /usr/local/nginx/sbin
./nginx -s quit
</code></pre><h3 id="重启nginx"><a href="#重启nginx" class="headerlink" title="重启nginx"></a>重启nginx</h3><p>方式一：先停止nginx，再启动</p>
<pre><code>./nginx -s quit
./nginx
</code></pre><p>方式二：不用先停止nginx，重新加载配置文件</p>
<pre><code>./nginx -s reload
</code></pre><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>nginx安装成功，即可访问安装nginx的主机IP（图床麻烦，就不放图了）</p>
<h1 id="nginx的主要运用场景"><a href="#nginx的主要运用场景" class="headerlink" title="nginx的主要运用场景"></a>nginx的主要运用场景</h1><p>1、http服务器。Nginx是一个http服务可以独立提供http服务。可以做网页静态服务器。<br>2、虚拟主机。可以实现在一台服务器虚拟出多个网站。例如个人网站使用的虚拟主机。<br>3、反向代理，负载均衡。当网站的访问量达到一定程度后，单台服务器不能满足用户的请求时，需要用多台服务器集群可以使用nginx做反向代理。并且多台服务器可以平均分担负载，不会因为某台服务器负载高宕机而某台服务器闲置的情况。</p>
<h1 id="配置虚拟主机"><a href="#配置虚拟主机" class="headerlink" title="配置虚拟主机"></a>配置虚拟主机</h1><p>虚拟主机是一种特殊的软硬件技术，它可以将网络上的每一台计算机分成多个虚拟主机，每个虚拟主机可以独立对外提供www服务，这样就可以实现一台主机对外提供多个web服务，每个虚拟主机之间是独立的，互不影响的。</p>
<p>三种类型的虚拟主机配置<br>1、基于ip的虚拟主机，<br>2、基于域名的虚拟主机<br>3、基于端口的虚拟主机 </p>
<h1 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h1><p>而反向代理（Reverse Proxy）方式是指以代理服务器来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求连接的客户端，此时代理服务器对外就表现为一个反向代理服务器。</p>
<h1 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h1><p>负载均衡，英文名称为Load Balance，其意思就是分摊到多个操作单元上进行执行，例如Web服务器、FTP服务器、企业关键应用服务器和其它关键任务服务器等，从而共同完成工作任务。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;自用学习笔记&lt;br&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
    
      <category term="nginx" scheme="http://yoursite.com/tags/nginx/"/>
    
  </entry>
  
  <entry>
    <title>BootStrap fileinput插件的使用</title>
    <link href="http://yoursite.com/2017/04/28/BootStrap-fileinput%E6%8F%92%E4%BB%B6%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2017/04/28/BootStrap-fileinput插件的使用/</id>
    <published>2017-04-28T12:15:14.000Z</published>
    <updated>2017-04-28T15:36:30.103Z</updated>
    
    <content type="html"><![CDATA[<p>BootStrap fileinput是一款基于bootstrap的上传组件<br><a id="more"></a><br>bootstrap fileinput这款插件使用简单方便，但还是有比较多的坑，因为官网的使用API真的好烂，描述的不够清楚<br><a href="http://plugins.krajee.com/file-input" target="_blank" rel="external">BootStrap fileinput官网</a></p>
<h1 id="引入css和js"><a href="#引入css和js" class="headerlink" title="引入css和js"></a>引入css和js</h1><h3 id="css文件"><a href="#css文件" class="headerlink" title="css文件"></a>css文件</h3><pre><code>&lt;link rel=&quot;stylesheet&quot; href=&quot;./resources/css/bootstrap.min.css&quot;&gt;
&lt;link rel=&quot;stylesheet&quot; href=&quot;./resources/css/fileinput.min.css&quot;&gt;
</code></pre><h3 id="js文件"><a href="#js文件" class="headerlink" title="js文件"></a>js文件</h3><pre><code>&lt;script type=&quot;text/JavaScript&quot; src=&quot;./resources/js/jQuery.min.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot; src=&quot;./resources/js/fileinput.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot; src=&quot;./resources/js/zh.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot; src=&quot;./resources/js/bootstrap.min.js&quot;&gt;&lt;/script&gt;
</code></pre><h1 id="定义上传标签"><a href="#定义上传标签" class="headerlink" title="定义上传标签"></a>定义上传标签</h1><pre><code>&lt;input type=&quot;file&quot; name=&quot;uploadPic&quot; id=&quot;uploadPic&quot; multiple class=&quot;file-loading&quot; /&gt;
</code></pre><p>###这里有个大坑啊，官网里写的class=“file”,但是如果是这样，那么你自己定义的配置就不会覆盖默认配置，也就是中文化无效，所有你的配置都不会起作用。应该是class=”file-loading”###</p>
<h1 id="初始化js"><a href="#初始化js" class="headerlink" title="初始化js"></a>初始化js</h1><pre><code>//初始化fileinput控件
function initFileInput(ctrlName, uploadUrl) {    
var control = $(&apos;#&apos; + ctrlName); 

control.fileinput({
    language: &apos;zh&apos;, //设置语言
    uploadUrl: uploadUrl, //上传的地址
    allowedFileExtensions: [&apos;jpg&apos;, &apos;gif&apos;, &apos;png&apos;],//接收的文件后缀
    showUpload: true, //是否显示上传按钮
    showCaption: false,//是否显示标题
    browseClass: &quot;btn btn-primary&quot;, //按钮样式     
    dropZoneEnabled: false,//是否显示拖拽区域
    minImageWidth: 50, //图片的最小宽度
    minImageHeight: 50,//图片的最小高度
    maxImageWidth: 1000,//图片的最大宽度
    maxImageHeight: 1000,//图片的最大高度
    maxFileSize: 0,//单位为kb，如果为0表示不限制文件大小
    minFileCount: 0,
    maxFileCount: 10, //表示允许同时上传的最大文件个数
    enctype: &apos;multipart/form-data&apos;,            
});
}


$(document).ready(function(){
    initFileInput(&quot;uploadPic&quot;, &quot;/upload/uploadPic&quot;).on(&quot;fileuploaded&quot;, function (event,data) {
    var data = response.data; // 特别注意，返回的data不可直接使用，需要使用response获取.
    //图片上传测试，这儿处理返回结果;后台返回的json数据
});;
</code></pre><h1 id="后台代码，可以直接用SpringMVC的MultipartFile"><a href="#后台代码，可以直接用SpringMVC的MultipartFile" class="headerlink" title="后台代码，可以直接用SpringMVC的MultipartFile"></a>后台代码，可以直接用SpringMVC的MultipartFile</h1>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;BootStrap fileinput是一款基于bootstrap的上传组件&lt;br&gt;
    
    </summary>
    
      <category term="JavaEE" scheme="http://yoursite.com/categories/JavaEE/"/>
    
    
      <category term="BootStrap-fileinput" scheme="http://yoursite.com/tags/BootStrap-fileinput/"/>
    
  </entry>
  
  <entry>
    <title>DWR使用教程</title>
    <link href="http://yoursite.com/2017/03/30/DWR%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/"/>
    <id>http://yoursite.com/2017/03/30/DWR使用教程/</id>
    <published>2017-03-30T13:23:24.000Z</published>
    <updated>2017-03-30T14:09:22.191Z</updated>
    
    <content type="html"><![CDATA[<p>Dwr (Direct Web Remoting)主要用于WEB界面和Java远程交互，是一个ajax远程调用框架。<a id="more"></a></p>
<h1 id="使用流程"><a href="#使用流程" class="headerlink" title="使用流程"></a>使用流程</h1><h3 id="下载dwr-jar"><a href="#下载dwr-jar" class="headerlink" title="下载dwr.jar"></a>下载dwr.jar</h3><h3 id="在web-xml中加入DwrServlet"><a href="#在web-xml中加入DwrServlet" class="headerlink" title="在web.xml中加入DwrServlet"></a>在web.xml中加入DwrServlet</h3><pre><code> &lt;!-- Ajax框架Dwr配置 --&gt;
&lt;servlet&gt;
    &lt;servlet-name&gt;dwr-invoker&lt;/servlet-name&gt;  
    &lt;servlet-class&gt;org.directwebremoting.servlet.DwrServlet&lt;/servlet-class&gt;  
    &lt;init-param&gt;
        &lt;param-name&gt;debug&lt;/param-name&gt;  
        &lt;param-value&gt;true&lt;/param-value&gt;  
    &lt;/init-param&gt;
    &lt;init-param&gt;
        &lt;param-name&gt;crossDomainSessionSecurity&lt;/param-name&gt;
        &lt;param-value&gt;false&lt;/param-value&gt;
   &lt;/init-param&gt;

&lt;/servlet&gt;
&lt;servlet-mapping&gt;
    &lt;servlet-name&gt;dwr-invoker&lt;/servlet-name&gt;  
    &lt;url-pattern&gt;/dwr/*&lt;/url-pattern&gt;  
&lt;/servlet-mapping&gt;
</code></pre><h3 id="在WEB-INF下建立Dwr核心配置文件，dwr-xml"><a href="#在WEB-INF下建立Dwr核心配置文件，dwr-xml" class="headerlink" title="在WEB-INF下建立Dwr核心配置文件，dwr.xml"></a>在WEB-INF下建立Dwr核心配置文件，dwr.xml</h3><pre><code>    &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
    &lt;!DOCTYPE dwr PUBLIC &quot;-//GetAhead Limited//DTD Direct Web Remoting 3.0//EN&quot; &quot;http://getahead.org/dwr//dwr30.dtd&quot;&gt; 
&lt;dwr&gt;  
&lt;allow&gt;  
    &lt;!-- javascript配置的是在使用js代码访问bean时bean的别名  
        也就是js代码中写userDWR.save();就如同userService所绑定的类UserServiceImpl  
            调用save方法也就是UserServiceImpl.save();  
    --&gt;

    &lt;!-- 用户 --&gt;
    &lt;create creator=&quot;spring&quot; javascript=&quot;userServiceDwr&quot; scope=&quot;application&quot;&gt;
        &lt;!-- value是spring容器中配置的bean的ID --&gt;
        &lt;param name=&quot;beanName&quot; value=&quot;userService&quot; /&gt;
        &lt;include method=&quot;userLogin&quot; /&gt;    &lt;!-- 用户登录 --&gt;
    &lt;/create&gt;
       &lt;/allow&gt;  
    &lt;/dwr&gt;
</code></pre><h3 id="浏览器访问项目中的dwr文件夹下自动生成的js文件，查看是否含有该方法"><a href="#浏览器访问项目中的dwr文件夹下自动生成的js文件，查看是否含有该方法" class="headerlink" title="浏览器访问项目中的dwr文件夹下自动生成的js文件，查看是否含有该方法"></a>浏览器访问项目中的dwr文件夹下自动生成的js文件，查看是否含有该方法</h3><h3 id="在jsp中引入js文件"><a href="#在jsp中引入js文件" class="headerlink" title="在jsp中引入js文件"></a>在jsp中引入js文件</h3><pre><code>&lt;script type=&apos;text/javascript&apos; src=&apos;../dwr/engine.js&apos;&gt; &lt;/script&gt;
&lt;script type=&apos;text/javascript&apos; src=&apos;../dwr/util.js&apos;&gt; &lt;/script&gt;
&lt;script type=&apos;text/javascript&apos; src=&apos;../dwr/interface/User.js&apos;&gt; &lt;/script&gt;
</code></pre><h3 id="javaScript中异步调用方法-需和Java代码中的方法一样，参数也一样"><a href="#javaScript中异步调用方法-需和Java代码中的方法一样，参数也一样" class="headerlink" title="javaScript中异步调用方法(需和Java代码中的方法一样，参数也一样)"></a>javaScript中异步调用方法(需和Java代码中的方法一样，参数也一样)</h3><pre><code> userServiceDwr.userLogin(name,password, function(data) {
 //回调函数，设置回调值
}
</code></pre><h3 id="其他注意点"><a href="#其他注意点" class="headerlink" title="其他注意点"></a>其他注意点</h3><ul>
<li>engine.js 它是Dwr客户端的核心，用来把动态的Javascript对象转换成服务器端的java对象，所以用到Dwr的地方就要用到它。</li>
<li>util.js 这个是Dwr提供的工具类，里面提供了一些javascript的封装函数以及选择器</li>
<li>和Spring可以完美结合</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Dwr (Direct Web Remoting)主要用于WEB界面和Java远程交互，是一个ajax远程调用框架。
    
    </summary>
    
      <category term="JavaEE" scheme="http://yoursite.com/categories/JavaEE/"/>
    
    
      <category term="DWR" scheme="http://yoursite.com/tags/DWR/"/>
    
  </entry>
  
  <entry>
    <title>程序是怎么跑起来的读书笔记</title>
    <link href="http://yoursite.com/2017/02/26/%E7%A8%8B%E5%BA%8F%E6%98%AF%E6%80%8E%E4%B9%88%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2017/02/26/程序是怎么跑起来的读书笔记/</id>
    <published>2017-02-26T03:23:09.000Z</published>
    <updated>2017-02-26T03:37:04.394Z</updated>
    
    <content type="html"><![CDATA[<p>《程序是怎么跑起来的》读书笔记，自用笔记……</p>
<a id="more"></a>
<h1 id="程序是怎样跑起来的"><a href="#程序是怎样跑起来的" class="headerlink" title="程序是怎样跑起来的"></a>程序是怎样跑起来的</h1><h2 id="CPU、内存、指令、硬盘是什么？"><a href="#CPU、内存、指令、硬盘是什么？" class="headerlink" title="CPU、内存、指令、硬盘是什么？"></a>CPU、内存、指令、硬盘是什么？</h2><p><strong>CPU:</strong> CPU是中央处理器，相当于计算机的大脑，主要负责计算机的运算和控制，内部由控制器，寄存器，运算器，时钟组成。各部分之间通过电流信号连通。其中跟程序运行关系最密切的一个部分就是寄存器，寄存器是用来暂存跟程序运行有关的指令和数据的。<strong>程序是吧寄存器作为对象来描述的。对程序员来说，cpu是具有各种功能寄存器的集合体</strong><br><strong>内存：</strong>就是一个存储器，通过控制芯片与cpu相连，主要用来存放指令和数据，cpu可以往内存里面存放数据和指令，也可以读取。<br><strong>指令：</strong>是机器语言中的一个语句，用来指挥计算机工作的命令。<br><strong>硬盘：</strong>用来长时间存储数据的设备，是外储存器的一种。</p>
<h2 id="CPU如何处理程序流程"><a href="#CPU如何处理程序流程" class="headerlink" title="CPU如何处理程序流程"></a>CPU如何处理程序流程</h2><p>操作系统把硬盘中的程序复制到内存中，cpu通过指令和寄存器将程序编译后，将高级语言转换成计算机能够直接识别的机器语言文件，程序运行时，在内存中生成机器语言的文件的副本，cpu开始执行程序，根据时钟信号，控制器从内存中读取指令和数据，通过对这些指令解释和运行，运算器就会对数据进行运算，控制器会根据运算结果来控制计算机的输入输出和一些行为。</p>
<h2 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h2><h2 id="未完待续。。。。。"><a href="#未完待续。。。。。" class="headerlink" title="未完待续。。。。。"></a>未完待续。。。。。</h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《程序是怎么跑起来的》读书笔记，自用笔记……&lt;/p&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="http://yoursite.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="程序是怎么跑起来的" scheme="http://yoursite.com/tags/%E7%A8%8B%E5%BA%8F%E6%98%AF%E6%80%8E%E4%B9%88%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/"/>
    
  </entry>
  
  <entry>
    <title>mysql和Oracle实现分页</title>
    <link href="http://yoursite.com/2017/02/08/mysql%E5%92%8COracle%E5%AE%9E%E7%8E%B0%E5%88%86%E9%A1%B5/"/>
    <id>http://yoursite.com/2017/02/08/mysql和Oracle实现分页/</id>
    <published>2017-02-08T09:41:34.000Z</published>
    <updated>2017-02-08T10:17:10.509Z</updated>
    
    <content type="html"><![CDATA[<p>mysql和Oracle实现分页<br><a id="more"></a></p>
<h1 id="mysql实现分页的方式"><a href="#mysql实现分页的方式" class="headerlink" title="mysql实现分页的方式"></a>mysql实现分页的方式</h1><p>利用的limit函数，LIMIT [offset,rows]查询从offset记录开始查询rows条记录 </p>
<pre><code>select * from limit offset,rows
</code></pre><h1 id="Oracle数据库实现分页"><a href="#Oracle数据库实现分页" class="headerlink" title="Oracle数据库实现分页"></a>Oracle数据库实现分页</h1><p>标准的写法<br>SELECT t2.<em><br>FROM<br>(<br>SELECT<br>t1.</em>, rownum rn<br>FROM<br>(<br>SELECT *<br>FROM tb_courseinfo<br>) t1<br>WHERE rownum &lt;= 150<br>) t2<br>WHERE rn &gt; 100</p>
<p>性能最好的写法：(rownum &lt;= 100 是固定的)<br>SELECT t1.<em><br>FROM<br>(<br>SELECT </em><br>FROM tb_courseinfo<br>WHERE id &gt; #maxId#<br>ORDER BY id<br>) t1<br>WHERE rownum &lt;= 100</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;mysql和Oracle实现分页&lt;br&gt;
    
    </summary>
    
      <category term="JavaEE" scheme="http://yoursite.com/categories/JavaEE/"/>
    
    
      <category term="mysql和Oracle实现分页" scheme="http://yoursite.com/tags/mysql%E5%92%8COracle%E5%AE%9E%E7%8E%B0%E5%88%86%E9%A1%B5/"/>
    
  </entry>
  
  <entry>
    <title>有关异常捕获的一题面试题</title>
    <link href="http://yoursite.com/2017/02/08/%E6%9C%89%E5%85%B3%E5%BC%82%E5%B8%B8%E6%8D%95%E8%8E%B7%E7%9A%84%E4%B8%80%E9%A2%98%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>http://yoursite.com/2017/02/08/有关异常捕获的一题面试题/</id>
    <published>2017-02-08T09:34:17.000Z</published>
    <updated>2017-02-08T09:37:56.258Z</updated>
    
    <content type="html"><![CDATA[<p>一题做错的面试题<br><a id="more"></a><br>        package Test;<br>        public class Test {<br>        private static void test(int[]arr) {<br>        for (int i = 0; i &lt; arr.length; i++) {<br>            try {<br>                if (arr[i] % 2 == 0) {<br>                    throw new NullPointerException();<br>                } else {<br>                    System.out.print(i);<br>                }<br>            } finally {<br>                System.out.print(“e”);<br>            }<br>        }<br>        }</p>
<pre><code>public static void main(String[]args) {
try {
    test(new int[] {0, 1, 2, 3, 4, 5});
} catch (Exception e) {
    System.out.print(&quot;E&quot;);
}
}
}
</code></pre><p>解答：输出eE<br>由于arr[0] =0,所以在进入 test()方法里面会在第一个if 上抛出一个 NullPointerException,接着会执行 finally 的语句, (finally语句先于 return 和 throw语句执行)，输出一个’e，然后回到 main方法中，由于捕捉到异常，所以进入到catch语句中，然后打印一个’E’,所以最终结果为”eE”</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一题做错的面试题&lt;br&gt;
    
    </summary>
    
      <category term="面试题" scheme="http://yoursite.com/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
      <category term="异常捕获" scheme="http://yoursite.com/tags/%E5%BC%82%E5%B8%B8%E6%8D%95%E8%8E%B7/"/>
    
  </entry>
  
  <entry>
    <title>JQuery、EasyUI和Bootstrap区别</title>
    <link href="http://yoursite.com/2017/02/08/JQuery%E3%80%81EasyUI%E5%92%8CBootstrap%E5%8C%BA%E5%88%AB/"/>
    <id>http://yoursite.com/2017/02/08/JQuery、EasyUI和Bootstrap区别/</id>
    <published>2017-02-08T08:50:30.000Z</published>
    <updated>2017-02-08T09:28:57.756Z</updated>
    
    <content type="html"><![CDATA[<p>JQuery，EasyUI和Bootstrap之间有什么区别？</p>
<a id="more"></a>
<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p><strong>jQuery:</strong> jQuery是一套跨浏览器的JavaScript库，简化HTML与JavaScript之间的操作。<br><strong>EasyUI:</strong> easyui是一种基于jQuery的用户界面插件集合。<br><strong>Bootstrap:</strong> Bootstrap是一组用于网站和网络应用程序开发的开源前端框架，包括HTML、CSS及JavaScript的框架 </p>
<h1 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h1><p>JQuery是操作dom的js库而Bootstrap是css库。JQuery专注行为动作，EasyUI是插件偏重于界面显示，使用js实现；Bootstrap更关注样式结构，偏重于使用css实现，基于JQuery</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;JQuery，EasyUI和Bootstrap之间有什么区别？&lt;/p&gt;
    
    </summary>
    
      <category term="JavaEE" scheme="http://yoursite.com/categories/JavaEE/"/>
    
    
      <category term="Jquery" scheme="http://yoursite.com/tags/Jquery/"/>
    
      <category term="EasyUI" scheme="http://yoursite.com/tags/EasyUI/"/>
    
      <category term="Bootstrap" scheme="http://yoursite.com/tags/Bootstrap/"/>
    
  </entry>
  
  <entry>
    <title>过滤器filter</title>
    <link href="http://yoursite.com/2017/02/05/%E8%BF%87%E6%BB%A4%E5%99%A8filter/"/>
    <id>http://yoursite.com/2017/02/05/过滤器filter/</id>
    <published>2017-02-05T14:41:33.000Z</published>
    <updated>2017-02-05T15:17:49.651Z</updated>
    
    <content type="html"><![CDATA[<p>Filter 的基本功能是对 Servlet 容器调用 Servlet 的过程进行拦截，从而在 Servlet 进行响应处理的前后实现一些特殊的功能。<br><a id="more"></a></p>
<h1 id="过滤器概述"><a href="#过滤器概述" class="headerlink" title="过滤器概述"></a>过滤器概述</h1><p>管理所有的web资源，不管出和进都要经过他。<br>过滤器就是一个保安，能对请求和响应进行拦截。<br>过滤器的执行顺序按照web.xml的标签顺序来执行<br>过滤器的初始化是在加载应用的时候，而不是用户第一次访问的时候。<br>过滤器的销毁是随服务器的关闭而销毁<br>过滤器，是一种职责链设计模式      </p>
<h1 id="过滤器编写步骤"><a href="#过滤器编写步骤" class="headerlink" title="过滤器编写步骤"></a>过滤器编写步骤</h1><ol>
<li><p>建立类实现接口  </p>
<pre><code>//注意所有的包都是javax.servlet.*的
public class FilterDemo1 implements Filter {
private FilterConfig filterConfig;
public FilterDemo1() {
}
public void destroy() {
}
//对于在拦截范围内的资源(web.xml配置），每次访问，该方法都会执行拦截
public void doFilter(ServletRequest request, ServletResponse response,
    FilterChain chain) throws IOException, ServletException {
String value = filterConfig.getInitParameter(&quot;aaa&quot;);
System.out.println(value);
System.out.println(&quot;FilterDemo1 start&quot;);
//放行，放行后的代码在目标资源执行完成后，再执行
chain.doFilter(request, response);
System.out.println(&quot;FilterDemo1 end&quot;);
}
public void init(FilterConfig filterConfig) throws ServletException {
//在Tomcat启动的时候，就会运行初始化方法
this.filterConfig=filterConfig;
}
}
</code></pre></li>
<li><p>配置web.xml  </p>
<pre><code>&lt;filter&gt;&lt;!-- 按配置文件标签的顺序进行过滤 --&gt;
    &lt;filter-name&gt;FilterDemo1&lt;/filter-name&gt;
    &lt;filter-class&gt;com.felix.filter.FilterDemo1&lt;/filter-class&gt;
&lt;init-param&gt;
    &lt;param-name&gt;aaa&lt;/param-name&gt;
    &lt;param-value&gt;bbb&lt;/param-value&gt;
&lt;/init-param&gt;
&lt;/filter&gt;
&lt;filter-mapping&gt;
    &lt;filter-name&gt;FilterDemo1&lt;/filter-name&gt;
    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;!-- 拦截所有的web资源 --&gt;
&lt;/filter-mapping&gt;
</code></pre><h1 id="过滤器案例"><a href="#过滤器案例" class="headerlink" title="过滤器案例"></a>过滤器案例</h1></li>
</ol>
<h3 id="统一全站字符编码的过滤器"><a href="#统一全站字符编码的过滤器" class="headerlink" title="统一全站字符编码的过滤器"></a>统一全站字符编码的过滤器</h3><p>实现类</p>
<pre><code>public class CharacterEncodingFilter implements Filter {
private FilterConfig filterConfig;
public CharacterEncodingFilter() {
}
public void destroy() {
}
public void doFilter(ServletRequest request, ServletResponse response,
    FilterChain chain) throws IOException, ServletException {
//得到配置的参数,配置的参数在web.xml中去配
String encoding = filterConfig.getInitParameter(&quot;encoding&quot;);
if(encoding==null){
    //防止忘记配了
    encoding = &quot;UTF-8&quot;;
}
//中文请求参数乱码的解决方法（post方式提交）
request.setCharacterEncoding(encoding);
//解决输出到页面的中文乱码
response.setContentType(&quot;text/html;charset=&quot;+encoding);
//不要忘记放行
chain.doFilter(request, response);
}
public void init(FilterConfig filterConfig) throws ServletException {
this.filterConfig = filterConfig;
}
} 
</code></pre><p>web.xml配置</p>
<pre><code>&lt;filter&gt;
    &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt;
    &lt;filter-class&gt;com.felix.filter.CharacterEncodingFilter&lt;/filter-class&gt;
    &lt;init-param&gt;
    &lt;param-name&gt;encoding&lt;/param-name&gt;
    &lt;param-value&gt;UTF-8&lt;/param-value&gt;
    &lt;/init-param&gt;
&lt;/filter&gt;
&lt;filter-mapping&gt;
    &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt;
    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
&lt;/filter-mapping&gt; 
</code></pre><h3 id="禁止浏览器缓存所有动态页面的过滤器"><a href="#禁止浏览器缓存所有动态页面的过滤器" class="headerlink" title="禁止浏览器缓存所有动态页面的过滤器"></a>禁止浏览器缓存所有动态页面的过滤器</h3><p>实现类</p>
<pre><code>public class NoCacheFilter implements Filter {
public NoCacheFilter() {
}
public void destroy() {
}
//不要缓存文件，只要设置3个头就可以了，然后在web.xml里面进行配置即可
public void doFilter(ServletRequest req, ServletResponse resp,
    FilterChain chain) throws IOException, ServletException {
HttpServletRequest request = (HttpServletRequest) req;
HttpServletResponse response = (HttpServletResponse) resp;
response.setHeader(&quot;Expires&quot;, &quot;-1&quot;);//只要比当前时间小就行，一般设置为-1
response.setHeader(&quot;Cache-Control&quot;, &quot;no-cache&quot;);//1.1
response.setHeader(&quot;Pragma&quot;, &quot;no-cache&quot;);//1.0
chain.doFilter(request, response);//别忘了放行
}
public void init(FilterConfig filterConfig) throws ServletException {
}
}
</code></pre><p>web.xml配置</p>
<pre><code>&lt;filter&gt;
    &lt;filter-name&gt;NoCacheFilter&lt;/filter-name&gt;
    &lt;filter-class&gt;com.felix.filter.NoCacheFilter&lt;/filter-class&gt;
&lt;/filter&gt;
&lt;filter-mapping&gt;
    &lt;filter-name&gt;NoCacheFilter&lt;/filter-name&gt;
    &lt;url-pattern&gt;/servlet/*&lt;/url-pattern&gt;
&lt;/filter-mapping&gt;
&lt;filter-mapping&gt;
    &lt;filter-name&gt;NoCacheFilter&lt;/filter-name&gt;
    &lt;url-pattern&gt;/servlet/*&lt;/url-pattern&gt;
&lt;/filter-mapping&gt; 
</code></pre><h3 id="控制浏览器缓存页面中的静态资源的过滤器"><a href="#控制浏览器缓存页面中的静态资源的过滤器" class="headerlink" title="控制浏览器缓存页面中的静态资源的过滤器"></a>控制浏览器缓存页面中的静态资源的过滤器</h3><p>实现类</p>
<pre><code>public class NeedCacheFilter implements Filter {
FilterConfig filterConfig;
public void init(FilterConfig filterConfig) throws ServletException {
this.filterConfig = filterConfig;
}
public NeedCacheFilter() {
}
public void destroy() {
}
public void doFilter(ServletRequest args0, ServletResponse args1,
    FilterChain chain) throws IOException, ServletException {
    //浏览器每一次请求会得到一个文件，每个文件是单独下载的
    //所以过滤器会对每个文件过滤一次。
HttpServletRequest request = (HttpServletRequest) args0;
HttpServletResponse response = (HttpServletResponse) args1;
//根据不同的资源，设置缓存时间
String htmlTime = filterConfig.getInitParameter(&quot;html&quot;);
String cssTime = filterConfig.getInitParameter(&quot;css&quot;);
String jsTime = filterConfig.getInitParameter(&quot;js&quot;);
long time = 0;
//根据访问的资源设定时间
//得到/my_exercise_day15_2/1.html
String uri = request.getRequestURI();
//得到文件后缀.方法是从指定的索引开始，到结束
String extendFileName = uri.substring(uri.lastIndexOf(&quot;.&quot;)+1);
if(&quot;html&quot;.equals(extendFileName));{
    time = Long.parseLong(htmlTime)*60*60*1000;
}
if(&quot;css&quot;.equals(extendFileName));{
    time = Long.parseLong(cssTime)*60*60*1000;
}
if(&quot;js&quot;.equals(extendFileName));{
    time = Long.parseLong(jsTime)*60*60*1000;
}//设置头，时间头
response.setDateHeader(&quot;Expires&quot;, System.currentTimeMillis()+time);
chain.doFilter(request, response);
}
}
</code></pre><p>web.xml配置</p>
<pre><code>&lt;filter&gt;
    &lt;filter-name&gt;NeedCacheFilter&lt;/filter-name&gt;
    &lt;filter-class&gt;com.felix.filter.NeedCacheFilter&lt;/filter-class&gt;
    &lt;init-param&gt;
        &lt;param-name&gt;html&lt;/param-name&gt;
        &lt;param-value&gt;2&lt;/param-value&gt;
    &lt;/init-param&gt;
    &lt;init-param&gt;
        &lt;param-name&gt;css&lt;/param-name&gt;
        &lt;param-value&gt;3&lt;/param-value&gt;
    &lt;/init-param&gt;
    &lt;init-param&gt;
        &lt;param-name&gt;js&lt;/param-name&gt;
        &lt;param-value&gt;4&lt;/param-value&gt;
    &lt;/init-param&gt;
&lt;/filter&gt;
</code></pre><h3 id="page指令的错误页面配置"><a href="#page指令的错误页面配置" class="headerlink" title="page指令的错误页面配置"></a>page指令的错误页面配置</h3><pre><code>&lt;filter&gt;
    &lt;filter-name&gt;FilterDemo&lt;/filter-name&gt;
    &lt;filter-class&gt;com.felix.filter.FilterDemo&lt;/filter-class&gt;
&lt;/filter&gt;
&lt;filter-mapping&gt;
       &lt;filter-name&gt;FilterDemo&lt;/filter-name&gt;
    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
        &lt;!-- 所有错误都会被过滤 --&gt;
    &lt;dispatcher&gt;ERROR&lt;/dispatcher&gt;
    &lt;!-- 所有转发都会被过滤--&gt;
    &lt;dispatcher&gt;FORWARD&lt;/dispatcher&gt;
    &lt;!-- 所有动态包含都会被过滤 --&gt;
    &lt;dispatcher&gt;INCLUDE&lt;/dispatcher&gt;
    &lt;!-- 所有请求都会被过滤 --&gt;
    &lt;dispatcher&gt;REQUEST&lt;/dispatcher&gt;
&lt;/filter-mapping&gt;
&lt;error-page&gt;&lt;!-- 配置错误页面 --&gt;
    &lt;!-- 需要抓住的异常是什么类型 --&gt;
    &lt;exception-type&gt;java.lang.Exception&lt;/exception-type&gt;
    &lt;!-- 出现错误后,需要转发到哪个页面 --&gt;
    &lt;location&gt;/error.jsp&lt;/location&gt;
&lt;/error-page&gt; 
</code></pre><h3 id="Struts2的web-xml配置"><a href="#Struts2的web-xml配置" class="headerlink" title="Struts2的web.xml配置"></a>Struts2的web.xml配置</h3><p>　项目中使用Struts2同样需要在web.xml配置过滤器，用来截取请求，转到Struts2的Action进行处理。</p>
<pre><code>&lt;!-- struts 2.x filter --&gt;
&lt;filter&gt;
    &lt;filter-name&gt;struts2&lt;/filter-name&gt;
    &lt;filter-class&gt;org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter&lt;/filter-class&gt;
&lt;/filter&gt;
&lt;filter-mapping&gt;
    &lt;filter-name&gt;struts2&lt;/filter-name&gt;
    &lt;url-pattern&gt;*.do&lt;/url-pattern&gt;
&lt;/filter-mapping&gt;
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Filter 的基本功能是对 Servlet 容器调用 Servlet 的过程进行拦截，从而在 Servlet 进行响应处理的前后实现一些特殊的功能。&lt;br&gt;
    
    </summary>
    
      <category term="JavaEE" scheme="http://yoursite.com/categories/JavaEE/"/>
    
    
      <category term="过滤器filter" scheme="http://yoursite.com/tags/%E8%BF%87%E6%BB%A4%E5%99%A8filter/"/>
    
  </entry>
  
  <entry>
    <title>Java中的网络编程</title>
    <link href="http://yoursite.com/2017/02/04/Java%E4%B8%AD%E7%9A%84%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    <id>http://yoursite.com/2017/02/04/Java中的网络编程/</id>
    <published>2017-02-04T11:55:25.000Z</published>
    <updated>2017-02-04T13:01:54.675Z</updated>
    
    <content type="html"><![CDATA[<p>有关Java网络编程的笔记整理<br><a id="more"></a></p>
<h1 id="网络通信三要素：IP地址，端口，还有传输协议"><a href="#网络通信三要素：IP地址，端口，还有传输协议" class="headerlink" title="网络通信三要素：IP地址，端口，还有传输协议"></a>网络通信三要素：IP地址，端口，还有传输协议</h1><h3 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h3><p>一个网络设备标识<br>Java中获取IP地址：</p>
<pre><code>//导包
import java.net.*;
public class IPDemo{
public static void main(String[] args)throws Exception{
    //获取InetAddress对象
    InetAddress ip = InetAddress.getByName(&quot;www.baidu.com&quot;);
    //然后调用InetAddress对象中的getHostAddress()方法获得IP
    //输出到控制台上看看结果吧：
    System.out.println(&quot;www.baidu.com的IP地址是：&quot;+ip.getHostAddress());
}
}
</code></pre><h3 id="端口"><a href="#端口" class="headerlink" title="端口"></a>端口</h3><p>用来标记进程的逻辑地址<br>1、端口的范围从0~65535（2的16次方减1）</p>
<p>2、系统保留端口为：0~1024</p>
<p>3、一些常用的端口，FTP：21，SMTP：25，HTTP：80</p>
<h3 id="传输协议：TCP、UPD"><a href="#传输协议：TCP、UPD" class="headerlink" title="传输协议：TCP、UPD"></a>传输协议：TCP、UPD</h3><h4 id="UPD协议"><a href="#UPD协议" class="headerlink" title="UPD协议"></a>UPD协议</h4><p>UPD协议特点：   </p>
<ol>
<li>将数据封装为数据包，面向无连接  </li>
<li>每个包大小限制在64kb   </li>
<li>因为面向无连接，所以速度快，不可靠  </li>
<li>有发送端与接收端  </li>
</ol>
<p>发送端的操作：<br>1、建立Socket服务，随便你指不指定端口，不指定系统分配。另外就是端口顺延，如果这次端口是1555，下次就是1556，因为当你运行完程序后，不能保证端口也释放了，为了防止出错。</p>
<p>2、将要发送的数据封装到包中。</p>
<p>3、发送数据，通过send方法发送出去，管它有没有收到呢。</p>
<p>4、关闭资源。 </p>
<pre><code>//发送端
//导包
import java.net.*;
public class UPDDemo{
public static void main(String[] args)throws Exception{

//创建Socket服务
DatagramSocket ds = new DatagramSocket();
//不指定端口也行，稍后在数据里指定。
//把数据打包
String data = &quot;UPD传输演示&quot;;
byte[] buf = data.getBytes();
//把数据转换成字节数组
DatagramPacket dp = new DatagramPacket(buf,
                          buf.length,
                          InetAddress.getByName(&quot;10.1.31.127&quot;),
                          10000);//通过名字获取IP，并指定端口

//发送数据
ds.send(dp);
//关闭资源
ds.close();
}
}
</code></pre><p>UPD接收端的操作：<br>1、建立服务</p>
<p>2、定义一个缓冲区来接受数据</p>
<p>3、调用DatagramPacket中的各种方法来达到我们的需求</p>
<p>4、关闭资源</p>
<pre><code>//接收端
//导包
import java.net.*;
public class UPDServer{
public static void main(String[] args)throws Exception{

//建立服务监视这个端口
DatagramSocket ds = new DatagramSocket(10000);

//定义一个缓冲区用于接收数据
byte[] buf = new byte[1024];//可以乘以64，因为一个包在64K以内。
DatagramPacket dp = new DatagramPacket(buf,buf.length);
ds.receive(dp);

//获取IP，这是一个习惯，因为要知道这数据是从那里来的
String ip = dp.getAddress().getHostAddress();
System.out.println(&quot;来自&quot;+ip+&quot;的数据是&quot;);

//把数据弄出来吧
System.out.println(new String(buf,0,dp.getLength()));

//关闭资源
ds.close();        
}
}
</code></pre><h4 id="TCP协议"><a href="#TCP协议" class="headerlink" title="TCP协议"></a>TCP协议</h4><p>tcp协议特点：  </p>
<ol>
<li>基于IO流进行数据传输的，面向连接  </li>
<li>数据传输没有大小限制  </li>
<li>面向连接通过三次握手，四次挥手机制保证数据的完整性和可靠性   </li>
<li>面向连接，速度慢   </li>
<li>分为服务端和客户端   </li>
</ol>
<p>客户端的操作步骤：   </p>
<p>1、建立服务Socket</p>
<p>2、获取输出流，把数据变成字节数组， 通过输出流发送给服务端。</p>
<p>3、关闭输出流，获取输入流，获取反馈信息</p>
<p>4、关闭资源</p>
<pre><code>//导包
import java.io.*;
import java.net.*;

public class TCPClient {

public static void main(String[] args) {

// 创建服务
Socket s = null;
try {
    if (s == null)
        s = new Socket(&quot;10.1.31.127&quot;, 13000);
    //把数据转换成字节数组
    byte[] buf = &quot;TCP传输演示&quot;.getBytes();

    //获取输出流
    OutputStream out = s.getOutputStream();
    //发送数据
    out.write(buf);

    //关闭发送流
    s.shutdownOutput();

    //获取输入流，获取反馈信息
    InputStream in = s.getInputStream();
    byte[] buffer  = new byte[1024];
    int len = in.read(buffer);

    //打印反馈信息
    System.out.println(new String(buffer,0,len));
    } catch (Exception e) {
    System.out.println(e.toString());
    }finally{
    if(s!=null){
        try{
            s.close();
        }catch(Exception e)
        {
            System.out.println(e.toString());}
        }
    }

}
}
</code></pre><p>服务端操作步骤：<br>1、建立服务ServerSocket服务，然后。用ServerSocket的accept（）方法得到Socket服务</p>
<p>2、获取输入流，然后可以得到数据</p>
<p>3、对读到的数据进行处理</p>
<p>4、反馈信息给客户端</p>
<p>5、各种关闭资源</p>
<pre><code>    //导包
import java.io.*;
import java.net.*;

public class TCPServer {

public static void main(String[] args)throws Exception {

    //创建服务
    ServerSocket ss = new ServerSocket(13000);

    Socket s = ss.accept();
    //先搞到IP地址
    String ip = s.getInetAddress().getHostAddress();

    //输出链接上来的机器
    System.out.println(ip+&quot;-----connected&quot;);

    //获取输入流
    InputStream in  = s.getInputStream();
    //读取数据
    byte[] buf = new byte[1024];

    int len = 0;
    while((len = in.read(buf))!=-1){
        //打印到控制台上吧
        System.out.println(new String(buf,0,len));
    }
    s.shutdownInput();

    //发送反馈信息

    OutputStream out = s.getOutputStream();

    out.write(&quot;服务端收到啦&quot;.getBytes());

    //关闭资源
    s.close();
    ss.close();
}

}
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;有关Java网络编程的笔记整理&lt;br&gt;
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java中的网络编程" scheme="http://yoursite.com/tags/Java%E4%B8%AD%E7%9A%84%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>MongoDB数据库</title>
    <link href="http://yoursite.com/2017/02/03/MongoDB%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    <id>http://yoursite.com/2017/02/03/MongoDB数据库/</id>
    <published>2017-02-03T15:15:43.000Z</published>
    <updated>2017-02-03T15:58:34.404Z</updated>
    
    <content type="html"><![CDATA[<p>MongoDB数据库学习笔记整理<br><a id="more"></a></p>
<h1 id="NoSql数据库"><a href="#NoSql数据库" class="headerlink" title="NoSql数据库"></a>NoSql数据库</h1><p>非关系型数据库，CouchDB，<strong>Redis</strong>，BigTable（谷歌的，付费），Neo4j ，HBase （Hadoop经常用），<strong>MongoDB</strong></p>
<h3 id="NoSql优缺点"><a href="#NoSql优缺点" class="headerlink" title="NoSql优缺点"></a>NoSql优缺点</h3><p>优点：<br>简单的扩展，快速的读写，低廉的成本，灵活的数据模型<br>缺点：<br>不提供对SQL的支持，支持的特性不够丰富，现有的产品不够成熟</p>
<h1 id="MongoDB数据库"><a href="#MongoDB数据库" class="headerlink" title="MongoDB数据库"></a>MongoDB数据库</h1><p>MongoDB由数据库（database）、集合（collection）、文档对象（document）组成<br>MongoDB里的集合对应于关系型数据库里的表，但是集合中没有列、行和关系的概念，集合中只有文档，一个文档就相当于一条记录，这体现了模式自由的特点   </p>
<h3 id="MongoDB数据类型"><a href="#MongoDB数据类型" class="headerlink" title="MongoDB数据类型"></a>MongoDB数据类型</h3><pre><code>数据类型                描述                            举例                                                          
null                  表示空值或者未定义的对象           {&quot;x&quot;:null}                
布尔值                  真或者假：true或者false           {&quot;x&quot;:true}
32位整数             32位整数。shell是不支持该类型的，shell中默认会转换成64位浮点数      
64位整数             64位整数。shell是不支持该类型的，shell中默认会转换成64位浮点数      
64位浮点数           64位浮点数。shell中的数字就是这一种类型  {&quot;x&quot;：3.14，&quot;y&quot;：3}
字符串                 UTF-8字符串                                          {&quot;foo&quot;:&quot;bar&quot;}
符号                 shell不支持，shell会将数据库中的符号类型的数据自动转换成字符串      
对象id                  文档的12字节的唯一id                                  {&quot;id&quot;: ObjectId()}（特有的，就这么写） 
日期                 从标准纪元开始的毫秒数                                  {&quot;date&quot;:new Date()}
正则表达式          文档中可以包含正则表达式，遵循JavaScript的语法  {&quot;foo&quot;:/foobar/i}
代码                文档中可以包含JavaScript代码                          {&quot;x&quot;：function() {}}     
未定义                undefined                                                  {&quot;x&quot;：undefined}
数组               值的集合或者列表                                          {&quot;arr&quot;: [&quot;a&quot;,&quot;b&quot;]}
内嵌文档          文档可以作为文档中某个key的value           {&quot;x&quot;:{&quot;foo&quot;:&quot;bar&quot;}}（可以无限内嵌）
</code></pre><h3 id="三种方式启动数据库"><a href="#三种方式启动数据库" class="headerlink" title="三种方式启动数据库"></a>三种方式启动数据库</h3><ul>
<li><p>第一种，命令行中输入：  </p>
<pre><code>mongod --dbpath=C:\release\mongo_data
</code></pre></li>
<li><p>第二种，批处理：<br>建立批处理文件，并在文件中写  </p>
<pre><code>mongod --dbpath=C:\release\mongo_data 
</code></pre></li>
<li><p>第三种，注册服务</p>
<pre><code>D:\mongodb\bin\mongod.exe --logpath D:\mongo_log\mongodb.log --logappend --dbpath D:\mongo_data --directoryperdb --serviceName MongoDB --install
</code></pre></li>
</ul>
<p>从系统服务中移除此服务：   </p>
<pre><code>D:\mongodb\bin\mongod.exe --logpath D:\mongo_log\mongodb.log --logappend --dbpath D:\mongo_data --directoryperdb --serviceName MongoDB --remove
</code></pre><ul>
<li>mongo_data中的文件：<br>local.0：本地数据储存的地方<br>local.ns—namespace，名称空间<br>mongod.lock—锁    </li>
</ul>
<h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><p>show dbs ：查看所有数据库<br>use mydb1：创建数据库mydb1（有就使用，没有就创建）：<br>db.dropDatabase()：删除当前数据库：<br>db：查看当前所在数据库：<br>show collections 或使用show tables：查看当前数据库中所有的集合：<br>db.createCollection(“集合名称”)：显示方式创建集合<br>db.集合名称.insert({})：隐式方式创建集合，并同时向集合中插入数据,例如：db.customer.insert({name:”jack”})<br>db.集合名称.remove({删除条件})：删除集合中符合条件的记录，没有条件则删除全部：db.c1.remove({name:”user1”})   </p>
<h3 id="查询集合中的文档"><a href="#查询集合中的文档" class="headerlink" title="查询集合中的文档"></a>查询集合中的文档</h3><p>db.集合名称.find({条件})：根据条件查询集合中的文档：db.c1.find({name:”name1”})<br>集合名称.findOne()：查询第一个文档<br>db.user.find({name:”name0”},{age:0})：投影查询，第一个参数，表示查询条件，第二个显示哪些字段（最好使用ture和false）             </p>
<p>查询集合中的文档 ，使用条件表达式：<br>db.collection.find({field:{$gt:value}});//大于： field &gt; value<br>db.collection.find({field:{$lt:value}});//小于： field &lt; value<br>db.collection.find({field:{$gte:value}});//大于等于： field &gt;= value<br>db.collection.find({field:{$lte:value}});//小于等于： field &lt;= value<br>db.collection.find({field:{$ne:value}});//不等于：  field != value<br>查询集合中的文档 ，统计(count)、排序(sort)、分页(skip、limit)<br>db.customer.count()：查询集合中有多少个文档<br>db.customer.find({age:{$lt:5}}).count()：查询集合中符合条件的有多少个文档<br>db.customer.find().sort({age:1})：给查询出来的文档按age的值进行排序，1为正序，0为倒叙<br>db.customer.find().skip(2).limit(3)：<br>db.customer.find().sort({age:-1}).skip(2).limit(3);<br>db.customer.find().sort({age:-1}).skip(2).limit(3).count();<br>count()命令默认参数是0，意思是直接跟随find，参数为1，则表示跟随在自己所在的位置<br>count，sort，和分页命令位置随便放，但是执行的顺序不会变化，例如sort放在最后和放在前面是一样的结果   </p>
<h3 id="更新集合中的文档"><a href="#更新集合中的文档" class="headerlink" title="更新集合中的文档"></a>更新集合中的文档</h3><p>db.collection.update(criteria,objNew,upsert,multi)<br>db.c2.update({name:”name0”},{name:”jack”})<br>参数说明：<br>criteria：用于设置查询条件的对象（相当于SQL里的where）<br>objNew：用于设置更新内容的对象（改成谁）<br>upsert：0（一般选择），如果存在则更新，不存在则什么都不做。1，如果没有找到，就插入（新增）这个记录。<br>multi：0，有多个符合条件的记录，只更新第一个。1，一般选择，有多个符合条件的记录，更新全部      </p>
<h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><p>创建普通索引，使用命令 db.collection.ensureIndex({key:1})<br>给name增加了一个索引，在system.indexes里面可以看到<br>创建唯一索引，使用命令 db.collection.ensureIndex({key:1}，{unique:true})<br> 查看关于索引的相关信息，使用命令 db.collection.stats()<br> 查看查询使用索引的情况，使用命令   db.collection.find({key:value}).explain()<br> 删除索引，使用命令 db.collection.dropIndex({key:1})    </p>
<h3 id="固定集合"><a href="#固定集合" class="headerlink" title="固定集合"></a>固定集合</h3><p>固定集合指的是事先创建而且大小固定的集合 。如果空间不足，最早的文档就会被删除，为新的文档腾出空间。<br>创建固定集合使用命令： </p>
<pre><code>db.createCollection(“collectionName”{capped:true,size:100000,max:100});           
</code></pre><p>size指定集合大小，单位为KB，max指定文档的数量。只要有一个参数超过，就开始删除旧文件腾空间。      </p>
<h3 id="备份、恢复和导入、导出"><a href="#备份、恢复和导入、导出" class="headerlink" title="备份、恢复和导入、导出"></a>备份、恢复和导入、导出</h3><p>备份(mongodump)和恢复(mongorestore)导入(mongoimport)和导出(mongoexport)</p>
<ul>
<li><p>备份数据使用下面的命令：</p>
<pre><code>操作系统&gt;mongodump -h dbhost -d dbname -o dbdirectory
</code></pre><p>-h：MongDB所在服务器地址，例如：127.0.0.1，当然也可以指定端口号：127.0.0.1:27017<br>-d：需要备份的数据库实例，例如：test<br>-o：备份的数据存放位置，例如：c:\data\dump，当然该目录需要提前建立，在备份完成后，系统自动在dump目录下建立一个test目录，这个目录里面存放该数据库实例的备份数据    </p>
</li>
<li><p>恢复数据使用下面的命令：  </p>
<pre><code>操作系统&gt;mongorestore -h dbhost -d dbname -directoryperdb dbdirectory
</code></pre><p>-h：MongoDB所在服务器地址<br>-d：需要恢复的数据库实例，例如：test，当然这个名称也可以和备份时候的不一样，比如test2<br>-directoryperdb：备份数据所在位置，例如：c:\data\dump\test    </p>
</li>
<li><p>导出数据可以使用命令： </p>
<pre><code>操作系统&gt;mongoexport -h dbhost -d dbname -c collectionName -o output
</code></pre></li>
</ul>
<p>-h  数据库地址<br>-d 指明使用的库<br>-c 指明要导出的集合<br>-o 指明要导出的文件名（注意这里是文件，纯文本文件）      </p>
<ul>
<li><p>导入数据可以使用命令：</p>
<pre><code>操作系统&gt;mongoimport -h dbhost -d dbname -c collectionname output 
</code></pre></li>
</ul>
<p>-h  数据库地址<br>-d 指明使用的库<br>-c 指明要导入的集合   </p>
<h3 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h3><h3 id="Java连接数据库"><a href="#Java连接数据库" class="headerlink" title="Java连接数据库"></a>Java连接数据库</h3><pre><code>public class MongoTest {
/**
 * 查询数据库中的集合
 * @throws Exception 
 */
@Test
public void test1() throws Exception{
Mongo mongo = new Mongo(&quot;localhost&quot;,27017);//连接mongo服务器
//连接数据库test
DB db = mongo.getDB(&quot;test&quot;);
//连接到集合c2
DBCollection collection = db.getCollection(&quot;c2&quot;);
//查询数据库并返回结果集
DBCursor find = collection.find();
//通过游标进行打印
while(find.hasNext()){
    DBObject object = find.next();
    System.out.println(object);
}
mongo.close();
}
/**
 * 删除数据
 */
@Test
public void test2() throws Exception{
Mongo mongo = new Mongo(&quot;localhost&quot;,27017);//连接mongo服务器
DB db = mongo.getDB(&quot;test&quot;);
DBCollection collection = db.getCollection(&quot;c2&quot;);
//得到数据
DBObject query = new BasicDBObject(&quot;name&quot;,&quot;name1&quot;);
//删除数据，删除成功返回1，不成功返回0
WriteResult result = collection.remove(query);
System.out.println(result.getN());
mongo.close();
    }
} 
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;MongoDB数据库学习笔记整理&lt;br&gt;
    
    </summary>
    
      <category term="JavaEE" scheme="http://yoursite.com/categories/JavaEE/"/>
    
    
      <category term="MongoDB数据库" scheme="http://yoursite.com/tags/MongoDB%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>RESTful架构</title>
    <link href="http://yoursite.com/2017/02/01/RESTful%E6%9E%B6%E6%9E%84/"/>
    <id>http://yoursite.com/2017/02/01/RESTful架构/</id>
    <published>2017-02-01T13:14:41.000Z</published>
    <updated>2017-02-01T13:38:25.831Z</updated>
    
    <content type="html"><![CDATA[<p>在慕课网学习高并发秒杀项目的时候，老师提到了RESTFul，所以就去学习了一下；</p>
<a id="more"></a>
<h1 id="什么是RESTFul"><a href="#什么是RESTFul" class="headerlink" title="什么是RESTFul"></a>什么是RESTFul</h1><p>REST全称是Representational State Transfer，中文意思是表现层状态转化。   </p>
<ul>
<li>是一组架构约束条件和原则</li>
<li>兴起于Rails</li>
<li>一种优雅的URI表达方式</li>
<li>资源的状态和状态转移</li>
</ul>
<p>如果一个架构符合RESTFul约束条件和原则，则称其为RESTFul架构</p>
<h1 id="RESTFul规范"><a href="#RESTFul规范" class="headerlink" title="RESTFul规范"></a>RESTFul规范</h1><p>RESTFul规范实现是通过HTTP协议里面四个表示操作方式的动词：<br>（1）GET – 查询操作<br>（2）POST – 添加、修改操作（非幂等操作）<br>（3）PUT – 修改操作（幂等操作）<br>（4）DELETE – 删除操作<br>GET用来获取资源，POST用来新建资源（也可以用于更新资源），PUT用来更新资源，DELETE用来删除资源。</p>
<h1 id="示例–秒杀API的URL设计"><a href="#示例–秒杀API的URL设计" class="headerlink" title="示例–秒杀API的URL设计"></a>示例–秒杀API的URL设计</h1><p>/模块/资源/{标示}/集合1/….   </p>
<pre><code>GET  /seckill/list    秒杀列表  
GET  /seckill/{id}/detail    详情页
GET  /seckill/time/now   系统时间
POST   /seckill/{id}/exposer    暴露秒杀
POST   /seckill/{id}/{md5}/execution   执行秒杀
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在慕课网学习高并发秒杀项目的时候，老师提到了RESTFul，所以就去学习了一下；&lt;/p&gt;
    
    </summary>
    
      <category term="JavaEE" scheme="http://yoursite.com/categories/JavaEE/"/>
    
    
      <category term="RESTFul架构" scheme="http://yoursite.com/tags/RESTFul%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
</feed>
